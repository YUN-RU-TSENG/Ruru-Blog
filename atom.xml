<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruru-Front-End-Blog</title>
  
  <subtitle>Ruru Front-End-note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/YUN-RU-TSENG/"/>
  <updated>2020-07-17T18:32:19.571Z</updated>
  <id>https://github.com/YUN-RU-TSENG/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【 YDKJS 】Object</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/%E3%80%90%20Javascript%20%E3%80%91Object%20%E4%B8%AD%E7%9A%84%E7%89%A9%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BE%9E%E5%B8%B8%E8%A6%8B%E7%9A%84%20&#39;HI~I&#39;M%20LUSIR&#39;.toLowerCase()%20%E7%9C%8B%E9%9A%B1%E5%BC%8F%E8%BD%89%E5%9E%8B/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/%E3%80%90%20Javascript%20%E3%80%91Object%20%E4%B8%AD%E7%9A%84%E7%89%A9%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BE%9E%E5%B8%B8%E8%A6%8B%E7%9A%84%20&#39;HI~I&#39;M%20LUSIR&#39;.toLowerCase()%20%E7%9C%8B%E9%9A%B1%E5%BC%8F%E8%BD%89%E5%9E%8B/</id>
    <published>2020-07-16T16:04:05.000Z</published>
    <updated>2020-07-17T18:32:19.571Z</updated>
    
    <content type="html"><![CDATA[<h4 id="🎙🎙🎙-nbsp-nbsp-閱讀須知"><a href="#🎙🎙🎙-nbsp-nbsp-閱讀須知" class="headerlink" title="🎙🎙🎙 &nbsp; &nbsp; 閱讀須知"></a>🎙🎙🎙 &nbsp; &nbsp; 閱讀須知</h4><p>本文為筆者閱讀 <strong>You Don’t Know JavaScript</strong> 系列時的學習筆記，有鑒於日益嚴重的健忘問題，也沒有錢可以買銀杏護體，便開始了 <del>大抄</del> 筆記整理的行動 🏃，主要會對書中內容進行心得整理、紀錄一些當下遇到的神秘問題。歡迎一起討論交流，有任何錯誤也請各位大大不吝鞭笞，小菜雞不慎感激 🙇。</p><p><a href="https://www.animatedimages.org/cat-frogs-198.htm" target="_blank" rel="noopener"><img src="https://www.animatedimages.org/data/media/198/animated-frog-image-0204.gif" border="0" alt="animated-frog-image-0204" /></a></p><hr/><h2 id="物件的生成"><a href="#物件的生成" class="headerlink" title="物件的生成"></a>物件的生成</h2><p>Javascript 物件可以透過兩種方式生成：</p><ol><li>字面值</li><li>建構函式</li></ol><p>以上兩種方法有兩點明顯的差異：執行速度、設定物件屬性的方式。</p><h4 id="差異一：執行速度"><a href="#差異一：執行速度" class="headerlink" title="差異一：執行速度"></a>差異一：執行速度</h4><p>根據 ECMA 5 的描述使用字面值生成物件以及 new Object() 生成物件是相同的</p><blockquote><p>Let array be the result of creating a new object as if by the expression new Array() where Array is the standard built-in constructor with that name.</p></blockquote><p>不過這篇 <a href="https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array" target="_blank" rel="noopener">為什麼 arr = [] 比 arr = new Array 要快？</a> 文章的介紹（範例是 Array），兩者在編譯上的結果會發現，比起 [] 生成物件， new Object 要經過確認 new 並且查找 Array 的過程，以這點來說建構函式花費的時間更多。</p><p>看到編譯結果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]: ARRAY_INIT</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>: NEW, IDENTIFIER</span><br></pre></td></tr></table></figure><p>兩者編譯會如何執行：<br><strong>[]</strong>：<code>ARRAY_INIT</code> 初始化陣列<br><strong>new Array</strong>: <code>new</code> 先解析 <code>new</code> 透過 <code>IDENTIFIER</code> 了解要建構物件， 由於遇到了 <code>IDENTIFIER</code> 所以要查詢範圍鍊 …。</p><p>得知 new Array() 顯然要進行更多的步驟，於是會花費更多的時間。</p><p>了解了原因後，我再次按照該提問範例測試了兩者的差異，使用迴圈創造多個物件，分別使用 <code>{}</code> 以及 <code>new Object()</code> 配合 <code>console.timeEnd()</code> 測試，如下方的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'using[]'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">20000000</span>; i++)&#123;<span class="keyword">var</span> arr = []&#125;;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'using[]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'using new'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">20000000</span>; i++)&#123;<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()&#125;;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'using new'</span>)</span><br></pre></td></tr></table></figure><p>結果多次測試下，可以看見字面值方法始終大於 <code>new Object()</code>，在速率上更快：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using []: 524.794ms</span><br><span class="line">using new: 734.315ms</span><br></pre></td></tr></table></figure><p>但是目前若是迴圈生成的物件較少，結果差異並不明顯（迴圈太少，有時 new 會更快），有鑒於這篇文章有些時間，有可能是瀏覽器產生了一些優化，以及關於編譯部分，等待之後再深入研究。</p><blockquote><p>生成 byteCoode 方法： <code>node --print-bytecode xxx.js &gt; result.txt</code> 可以生成 bytecode 到特定 txt 中。等待研究 bytecode 再回來填坑。</p></blockquote><p>等待研究的資料</p><ol><li><a href="https://github.com/aszx87410/blog/issues/54">從 V8 bytecode 看 let 與 var 的效能問題</a></li><li><a href="https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775" target="_blank" rel="noopener">Understanding V8’s Bytecode</a></li></ol><h4 id="差異二：設定物件屬性的方式"><a href="#差異二：設定物件屬性的方式" class="headerlink" title="差異二：設定物件屬性的方式"></a>差異二：設定物件屬性的方式</h4><p>字面值設定屬性可以清晰的建立物件結構，並且一次新增多個屬性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticket = &#123;</span><br><span class="line">    name: <span class="string">'Movie'</span>,</span><br><span class="line">    price: <span class="number">20000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="danger">這裡的 `price` 後方加上的 `,` 稱為尾隨逗號 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas" target="_blank" rel="noopener">Trailing commas</a>，便於我們添加、刪除和移動屬性。所以要記得添加呦！☘</div><p>但透過建構式，屬性要生成後一個一個添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticket = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次新增一個</span></span><br><span class="line">ticket.name = <span class="string">'Movie'</span>;</span><br><span class="line"><span class="comment">// 一次新增一個</span></span><br><span class="line">ticket.price = <span class="number">20000</span></span><br></pre></td></tr></table></figure><p>鑑於方便性，在速率、初始設定多個數值時更為方便等優點，字面值總是為使用上的優先考量。</p><h2 id="物件屬性"><a href="#物件屬性" class="headerlink" title="物件屬性"></a>物件屬性</h2><p>物件是屬性（property）的集合，每個屬性都是一個（key/value）對，可以儲存 8 種數據類型（ 7 種基本型別 ）</p><p>string<br>number<br>boolean<br>null<br>undefined<br>BigInt : 大於 2 的 23 次方的數字，很大的數字。<br>Symbol</p><hr><p>object</p><p>其中每個屬性可以為命名數據屬性、命名訪問屬性、內部屬性（三者稍後說明），現在只要先記得這件事即可。</p><p>像是 function 物件不同於其他物件，它具有 [[call]] 屬性，內部屬性通常是為了規範定義、語言實行而存在的。</p><div class="danger">null 是基本型別為 Object 是設計上的失誤，細節可以參考 [“typeof null” 的歷史](https://2ality.com/2013/10/typeof-null.html) 介紹，雖然目前 TC39 積極想處理，但是目前仍為錯誤，我們可以看到 `typeof null = "object"`。</div><h4 id="神秘的小題目"><a href="#神秘的小題目" class="headerlink" title="神秘的小題目"></a>神秘的小題目</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Object</span> (a);</span><br><span class="line"><span class="built_in">console</span>.log (a === b)</span><br></pre></td></tr></table></figure><p>答案是 <code>true</code>，解答：<a href="https://www.zhihu.com/question/285068799/answer/1323222019" target="_blank" rel="noopener">這裏</a></p><h2 id="內建對象"><a href="#內建對象" class="headerlink" title="內建對象"></a>內建對象</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;🎙🎙🎙-nbsp-nbsp-閱讀須知&quot;&gt;&lt;a href=&quot;#🎙🎙🎙-nbsp-nbsp-閱讀須知&quot; class=&quot;headerlink&quot; title=&quot;🎙🎙🎙 &amp;nbsp; &amp;nbsp; 閱讀須知&quot;&gt;&lt;/a&gt;🎙🎙🎙 &amp;nbsp; &amp;nbsp
      
    
    </summary>
    
    
    
      <category term="scope" scheme="https://github.com/YUN-RU-TSENG/tags/scope/"/>
    
      <category term="javascript" scheme="https://github.com/YUN-RU-TSENG/tags/javascript/"/>
    
      <category term="YDKJavaScript" scheme="https://github.com/YUN-RU-TSENG/tags/YDKJavaScript/"/>
    
      <category term="You Don&#39;t Know JavaScript" scheme="https://github.com/YUN-RU-TSENG/tags/You-Don-t-Know-JavaScript/"/>
    
      <category term="Object" scheme="https://github.com/YUN-RU-TSENG/tags/Object/"/>
    
      <category term="instance" scheme="https://github.com/YUN-RU-TSENG/tags/instance/"/>
    
      <category term="new" scheme="https://github.com/YUN-RU-TSENG/tags/new/"/>
    
      <category term="get" scheme="https://github.com/YUN-RU-TSENG/tags/get/"/>
    
      <category term="set" scheme="https://github.com/YUN-RU-TSENG/tags/set/"/>
    
      <category term="reference" scheme="https://github.com/YUN-RU-TSENG/tags/reference/"/>
    
  </entry>
  
  <entry>
    <title>【 Vue 初探 】Vue instance</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/%E3%80%90Vue-%E5%88%9D%E6%8E%A2%E3%80%91Vue-instance/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/%E3%80%90Vue-%E5%88%9D%E6%8E%A2%E3%80%91Vue-instance/</id>
    <published>2020-07-11T18:33:42.000Z</published>
    <updated>2020-07-17T17:26:25.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本節重點"><a href="#本節重點" class="headerlink" title="本節重點"></a>本節重點</h2><ul><li>Vue instance 是什麼？該如何使用？</li><li>life cycle 生命週期介紹？</li></ul><h1 id="Vue-instance"><a href="#Vue-instance" class="headerlink" title="Vue instance"></a>Vue instance</h1><p>上章節的內容提及 Vue 最初源自 MVVM 設計，在初始版官方文件中提到（V0.11）：</p><p><strong>M</strong> - 由 JS 物件、基本資料物件構成。<br><strong>V</strong> - 由 Vue instance 所控制的 DOM，通常為我們所編譯的 <code>template</code>。<br><strong>VM</strong> - 同步 V 與 M 的 ViewModel 由 Vue instance 擔任。</p><p>透過 Vue instance，可以同步 View 以及 Model。這一章節會討論到如何建立 Vue instance，以及如何使用。</p><h2 id="Vue-instance-建立方式："><a href="#Vue-instance-建立方式：" class="headerlink" title="Vue instance 建立方式："></a>Vue instance 建立方式：</h2><p>根 Vue instance 透過 <code>new Vue</code> 建構式生成，該方式所填入的 <code>options</code> 物件才能使用 <code>el</code> 選項。在 Vue 中每一個組件也都是一個 instance，透過嵌套的方式層層疊疊的形成組件樹。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">/* options */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Vue-instance-options-object"><a href="#Vue-instance-options-object" class="headerlink" title="Vue instance options object"></a>Vue instance options object</h2><blockquote><p>可查閱官方文件 <a href="https://cn.vuejs.org/v2/api/#el" target="_blank" rel="noopener">vuejs.org</a></p></blockquote><p>每個 Vue instance 可以在創建時傳入 <code>options</code> 物件，為一選項物件包含 Vue instance 掛載的 DOM 位置、Data、mixin、生命週期回調訊息等，常用的選項屬性有：</p><h4 id="🧤-options-DOM：el"><a href="#🧤-options-DOM：el" class="headerlink" title="🧤 options/DOM：el"></a>🧤 options/DOM：el</h4><p>類型：String | Element<br>限制：只在使用 <code>new</code> 建構式創建的 instance 創建時有效<br>用途：提供一個實際存在的 DOM 元素作為 Vue instance 掛載的目標，可以填入 CSS 選擇器、HTMLElement。所選擇的 el 元素在掛載後會完全被替換，因此不推薦掛在 <code>html</code> 或 <code>body</code> 上。</p><h4 id="掛載範例："><a href="#掛載範例：" class="headerlink" title="掛載範例："></a>掛載範例：</h4><p>以下方例子來說，<code>div.app</code> 是 Vue instance 掛載的目標，將被 <code>p</code> 模板所替換，所以不建議使用 <code>html</code>、<code>body</code> 作為 Vue instance 掛載目標，這兩個元素將被取代帶來非預期的渲染結果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>instance 將掛載的元件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: `<span class="tag">&lt;<span class="name">p</span>&gt;</span>被替換上去的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span>`,</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  vm.$mount(<span class="string">".app"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最初為：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>instance 將掛載的元件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue instance 掛載後，<code>div.app</code> 被替換：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>被替換上去的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="若是不在-root-instance-的-options-中填入-el"><a href="#若是不在-root-instance-的-options-中填入-el" class="headerlink" title="若是不在 root instance 的 options 中填入 el"></a>若是不在 root instance 的 options 中填入 el</h4><p>若是不填入 el，Vue instance 將不會掛載直到手動掛載執行 <a href="https://cn.vuejs.org/v2/api/?#vm-mount" target="_blank" rel="noopener">vm.$mount</a>(‘要掛載的元素’) 後，才會掛載到 el 上。反之，一旦寫了 el，Vue instance 將直接被掛載。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: `<span class="tag">&lt;<span class="name">p</span>&gt;</span>被替換上去的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span>`,</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  <span class="comment">// 執行到 created 步驟</span></span></span><br><span class="line"><span class="actionscript">  vm.$mount(<span class="string">".app"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 開始執行 mounted 步驟</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要觀看 mount 掛載調用的生命週期執行，可使用以下方式，可以觀察到載手動掛載前生命週期鉤子調用到 <code>created</code> vm.$mount 後便將模板掛載到目標元素上，生命週期鉤子調用到 <code>mounted</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: `<span class="tag">&lt;<span class="name">p</span>&gt;</span>被替換上去的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span>`,</span></span></span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"beforeCreate -&gt; beforeCreate"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"在實例初始化之後，資料觀測 (data observer) 和 event/watcher 事件設定之前被呼叫。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"created -&gt; created"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"在實例建立完成後被立即呼叫。在這一步，實例已完成以下的設定：資料觀測 (data observer)，property 和方法的運算，watch/event 事件callback。然而，掛載階段還沒開始，$el property 目前尚不可用。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"beforeMount -&gt; beforeMount"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"在掛載開始之前被呼叫：相關的 render 函數首次被呼叫。"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"mounted -&gt; mounted"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"實例被掛載後呼叫，這時 el 被新建立的 vm.$el 替換了。如果根實例掛載到了一個檔案內的元素上，當 mounted 被呼叫時 vm.$el 也在檔案內。注意 mounted 不會保證所有的子組件也都一起被掛載。如果你希望等到整個視圖都渲染完畢，可以在 mounted 內部使用 vm.$nextTick："</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"beforeUpdate -&gt; beforeUpdate"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"資料更新時呼叫，發生在虛擬 DOM 打補丁之前。這裡適合在更新之前訪問現有的 DOM，比如手動移除已添加的事件監聽器。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"updated -&gt; updated"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"由於資料更改導致的虛擬 DOM 重新渲染和打補丁，在這之後會呼叫該鉤子。當這個鉤子被呼叫時，組件 DOM 已經更新，所以你現在可以執行依賴於 DOM 的操作。然而在大多數情況下，你應該避免在此期間更改狀態。如果要相應狀態改變，通常最好使用計算屬性或 watcher 取而代之。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"beforeDestroy -&gt; beforeDestroy"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"實例銷毀之前呼叫。在這一步，實例仍然完全可用。"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"destroyed -&gt; destroyed"</span>, destroyed);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"實例銷毀後呼叫。該鉤子被呼叫後，對應 Vue 實例的所有指令都被解綁，所有的事件監聽器被移除，所有的子實例也都被銷毀。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  <span class="comment">// 執行到 created 步驟</span></span></span><br><span class="line"><span class="actionscript">  vm.$mount(<span class="string">".app"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 開始執行 mounted 步驟</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="danger">在 instance 掛載後，元素可以透過 vm.$el 訪問。如果存在該 `el` 選項，則 Vue instance 立即進行編譯，否則需要透過 vm.$mount() 綁定。如果 template 和 render fun 皆不存在，則掛載 DOM 元素的 HTML 會被取出當作模板。</div><h2 id="生命週期"><a href="#生命週期" class="headerlink" title="生命週期"></a>生命週期</h2><p>Vue instance 創建時，會歷經一系列的初始化過程，如設定數據監聽、將模板掛載到目標元素等，在這些步驟執行過程中，你可以時間在特定時間調用 callback 函數去在特定時段添加特定的程式碼。</p><table><thead><tr><th>lifecycle hook</th><th>內容</th><th></th></tr></thead><tbody><tr><td>beforeCreate</td><td>在實例初始化之後，數據觀測 (data observer) 和 event/watcher 事件配置之前被調用。</td><td></td></tr><tr><td>created</td><td>在實例創建完成後被立即調用。在這一步，實例已完成以下的配置：數據觀測 (data observer)，property 和方法的運算，watch/event 事件回調。然而，掛載階段還沒開始， $el property 目前尚不可用。</td><td></td></tr><tr><td>beforeMount</td><td>在掛載開始之前被調用：相關的 render 函數首次被調用。 該鉤子在服務器端渲染期間不被調用。</td><td></td></tr><tr><td>mounted</td><td>實例被掛載後調用，這時 el 被新創建的 vm.$el 替換了。如果根實例掛載到了一個文檔內的元素上，當 mounted 被調用時 vm.$el 也在文檔內。 注意 mounted 不會保證所有的子組件也都一起被掛載。如果你希望等到整個視圖都渲染完畢，可以在 mounted 內部使用 vm.$nextTick</td><td></td></tr><tr><td>beforeUpdate</td><td>數據更新時調用，發生在虛擬 DOM 打補丁之前。這裡適合在更新之前訪問現有的 DOM，比如手動移除已添加的事件監聽器。 該鉤子在服務器端渲染期間不被調用，因為只有初次渲染會在服務端進行。</td><td></td></tr><tr><td>updated</td><td>由於數據更改導致的虛擬 DOM 重新渲染和打補丁，在這之後會調用該鉤子。 當這個鉤子被調用時，組件 DOM 已經更新，所以你現在可以執行依賴於 DOM 的操作。然而在大多數情況下，你應該避免在此期間更改狀態。如果要相應狀態改變，通常最好使用計算屬性或 watcher 取而代之。 注意 updated 不會保證所有的子組件也都一起被重繪。如果你希望等到整個視圖都重繪完畢，可以在 updated 裡使用 vm.$nextTick</td><td></td></tr><tr><td>beforeDestroy</td><td>實例銷毀之前調用。在這一步，實例仍然完全可用。</td><td></td></tr><tr><td>destroyed</td><td>實例銷毀後調用。該鉤子被調用後，對應 Vue 實例的所有指令都被解綁，所有的事件監聽器被移除，所有的子實例也都被銷毀。</td><td></td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">".app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">          num: 123,</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="handlebars"><span class="xml">        template: `<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; num &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>`,</span></span></span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeCreate -&gt; beforeCreate"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"在實例初始化之後，資料觀測 (data observer) 和 event/watcher 事件設定之前被呼叫。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        created() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"created -&gt; created"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"在實例建立完成後被立即呼叫。在這一步，實例已完成以下的設定：資料觀測 (data observer)，property 和方法的運算，watch/event 事件callback。然而，掛載階段還沒開始，$el property 目前尚不可用。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeMount -&gt; beforeMount"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"在掛載開始之前被呼叫：相關的 render 函數首次被呼叫。"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"mounted -&gt; mounted"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"實例被掛載後呼叫，這時 el 被新建立的 vm.$el 替換了。如果根實例掛載到了一個檔案內的元素上，當 mounted 被呼叫時 vm.$el 也在檔案內。注意 mounted 不會保證所有的子組件也都一起被掛載。如果你希望等到整個視圖都渲染完畢，可以在 mounted 內部使用 vm.$nextTick："</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeUpdate -&gt; beforeUpdate"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"資料更新時呼叫，發生在虛擬 DOM 打補丁之前。這裡適合在更新之前訪問現有的 DOM，比如手動移除已添加的事件監聽器。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"updated -&gt; updated"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"由於資料更改導致的虛擬 DOM 重新渲染和打補丁，在這之後會呼叫該鉤子。當這個鉤子被呼叫時，組件 DOM 已經更新，所以你現在可以執行依賴於 DOM 的操作。然而在大多數情況下，你應該避免在此期間更改狀態。如果要相應狀態改變，通常最好使用計算屬性或 watcher 取而代之。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeDestroy -&gt; beforeDestroy"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"實例銷毀之前呼叫。在這一步，實例仍然完全可用。"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"destroyed -&gt; destroyed"</span>, destroyed);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"實例銷毀後呼叫。該鉤子被呼叫後，對應 Vue 實例的所有指令都被解綁，所有的事件監聽器被移除，所有的子實例也都被銷毀。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue%20instance%20ec8d6e67b59e4767ac372188e1417cdd/Untitled.png"></p><p>等待筆記：<br><a href="https://011.vuejs.org/guide/components.html" target="_blank" rel="noopener">Vue.extend()</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本節重點&quot;&gt;&lt;a href=&quot;#本節重點&quot; class=&quot;headerlink&quot; title=&quot;本節重點&quot;&gt;&lt;/a&gt;本節重點&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Vue instance 是什麼？該如何使用？&lt;/li&gt;
&lt;li&gt;life cycle 生命週期介紹？&lt;/li&gt;
      
    
    </summary>
    
    
    
      <category term="vue" scheme="https://github.com/YUN-RU-TSENG/tags/vue/"/>
    
      <category term="instance" scheme="https://github.com/YUN-RU-TSENG/tags/instance/"/>
    
      <category term="vue Instance" scheme="https://github.com/YUN-RU-TSENG/tags/vue-Instance/"/>
    
      <category term="hook" scheme="https://github.com/YUN-RU-TSENG/tags/hook/"/>
    
      <category term="lifecycle" scheme="https://github.com/YUN-RU-TSENG/tags/lifecycle/"/>
    
      <category term="生命週期" scheme="https://github.com/YUN-RU-TSENG/tags/%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F/"/>
    
      <category term="實體" scheme="https://github.com/YUN-RU-TSENG/tags/%E5%AF%A6%E9%AB%94/"/>
    
      <category term="Vue 實體" scheme="https://github.com/YUN-RU-TSENG/tags/Vue-%E5%AF%A6%E9%AB%94/"/>
    
  </entry>
  
  <entry>
    <title>【 YDKJS 】什麼是 Scope？</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/YDKJS-%E4%BB%80%E9%BA%BC%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/YDKJS-%E4%BB%80%E9%BA%BC%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F/</id>
    <published>2020-07-06T16:16:41.000Z</published>
    <updated>2020-07-06T16:06:38.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>資料來源：<a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN">YDKJS 作用域與閉包 - 第一章</a></p></blockquote><h4 id="本篇提及："><a href="#本篇提及：" class="headerlink" title="本篇提及："></a>本篇提及：</h4><ul><li>scope</li><li>編譯器</li><li>引擎</li><li>RHS、LHS</li></ul><p>Scope 提供查找、儲存變數的一組規則，編譯器、引擎都會使用這組規則，在編譯器經歷詞法分析、解析後，便會將解析成抽象語法樹的 AST 轉化成機器代碼：</p><a id="more"></a><p>可以使用 node.js 查看 bytecode</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --print-bytecode ooxxoo.js</span><br></pre></td></tr></table></figure><h2 id="以實例查看-scope-與編譯器、引擎的互動"><a href="#以實例查看-scope-與編譯器、引擎的互動" class="headerlink" title="以實例查看 scope 與編譯器、引擎的互動"></a>以實例查看 scope 與編譯器、引擎的互動</h2><blockquote><p>以 <code>var S = 12</code>  為範例：</p></blockquote><p>在編譯器經歷詞法分析、解析後，在編譯上述代碼成機器碼時，會進行以下的動作：</p><ol><li>查看 <code>var S</code> 是否已存在當前 scope集合中，若是有則忽略該聲明；若是無則會讓 scope 在該 scope 集合中新增 <code>S</code> 變數。</li><li>編譯器生成 <code>S = 12</code> 的機器碼，以提供引擎稍後執行賦值的動作。引擎在執行該程式碼時，也會詢問 scope 中是否存在此變數</li></ol><h4 id="引擎詢問-scope-分為-LHS、-RHS"><a href="#引擎詢問-scope-分為-LHS、-RHS" class="headerlink" title="引擎詢問 scope 分為 LHS、 RHS"></a>引擎詢問 scope 分為 <code>LHS</code>、 <code>RHS</code></h4><p><code>LHS</code> 變數在左側，查詢是否存在，並且執行賦值操作。（不一定在左測，想成賦予數值的目標）</p><ul><li>當找尋不到時，且並非 <code>strict</code> 模式，會在全域中新增該變數。</li><li>當找尋不到時，且為 <code>strict</code> 模式，會拋出 <code>ReferenceError</code></li></ul><p><code>RHS</code> 變數在右側，查詢是否存在，並且返回其值。（不一定在右側，想成查找數值的源頭）</p><ul><li>當找尋不到時，會丟出 <code>ReferenceError</code></li><li>當找到但卻拿著該數值做不正確的行為（如拿基本型別去跑函式）則會丟出 <code>TypeError</code></li></ul><p><code>RHS</code></p><p>以下會發現變數 <code>a</code> 在右側，經過查詢得到其數值後便會被返回。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p><code>LHS</code></p><p>會查找該變數存在與否，並賦予新值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">22</span></span><br></pre></td></tr></table></figure><h5 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">foo</span> (<span class="params"> a </span>)  </span>&#123;</span><br><span class="line"><span class="built_in">console</span> . log (  a  ) ;  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo (  <span class="number">2</span>  ) ;</span><br></pre></td></tr></table></figure><p>scope 與引擎的交互：</p><ol><li><code>RHS</code> 查詢 foo 函式，並執行</li><li><code>LHS</code> 將 a 參數賦予數值 2</li><li><code>RHS</code> 查詢 console 是否存在</li><li><code>RHS</code> 查詢 a，並且 console 打印</li></ol><blockquote><p>注意：其中的 foo 函式並非 <code>var foo = function(){...}</code> 賦值的概念，此函數聲明一開始在編譯器生成時，就已經將函式賦予該變數。</p></blockquote><h2 id="巢狀-scope"><a href="#巢狀-scope" class="headerlink" title="巢狀 scope"></a>巢狀 scope</h2><p>就像程式碼被巢狀在另一堆程式碼中，作用域也是巢狀存在於其他作用域中的，如果該作用域找不到變數，引擎便會向外尋找。</p><p>像是 console 若在 foo 內找尋不著，便會向全域尋找。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">foo</span> (<span class="params"> a </span>)  </span>&#123;</span><br><span class="line"><span class="built_in">console</span> . log (  a  ) ;  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo (  <span class="number">2</span>  ) ;</span><br></pre></td></tr></table></figure><p>查找 console 時，若找到最頂層仍無（只是舉例，當然不會找不到），則會視是否有嚴格模式來決定是要給予錯誤或是將該變數新增到全域中。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;資料來源：&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN&quot;&gt;YDKJS 作用域與閉包 - 第一章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;本篇提及：&quot;&gt;&lt;a href=&quot;#本篇提及：&quot; class=&quot;headerlink&quot; title=&quot;本篇提及：&quot;&gt;&lt;/a&gt;本篇提及：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;scope&lt;/li&gt;
&lt;li&gt;編譯器&lt;/li&gt;
&lt;li&gt;引擎&lt;/li&gt;
&lt;li&gt;RHS、LHS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scope 提供查找、儲存變數的一組規則，編譯器、引擎都會使用這組規則，在編譯器經歷詞法分析、解析後，便會將解析成抽象語法樹的 AST 轉化成機器代碼：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="scope" scheme="https://github.com/YUN-RU-TSENG/tags/scope/"/>
    
      <category term="javascript" scheme="https://github.com/YUN-RU-TSENG/tags/javascript/"/>
    
      <category term="YDKJS" scheme="https://github.com/YUN-RU-TSENG/tags/YDKJS/"/>
    
  </entry>
  
  <entry>
    <title>【 網路基礎 】IP、DNS、HTTP request</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/%E5%88%9D%E6%8E%A2-Internet-%E5%9F%BA%E7%A4%8E%EF%BC%9AIP%E3%80%81DNS%E3%80%81HTTP-request/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/%E5%88%9D%E6%8E%A2-Internet-%E5%9F%BA%E7%A4%8E%EF%BC%9AIP%E3%80%81DNS%E3%80%81HTTP-request/</id>
    <published>2020-07-06T01:37:41.000Z</published>
    <updated>2020-07-06T08:42:57.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Internet-Protocol"><a href="#Internet-Protocol" class="headerlink" title="Internet Protocol"></a>Internet Protocol</h2><p>Internet Protocol，是一項網路協議，該協議的重點為 IP 位址，IP 位址是每個在 Internet 中的設備所擁有的唯一位址，通過這個位址我們可以輕鬆的找到其他的設備，不過 IP 位址、Internet 究竟是如何幫助我們在如今便捷的遨遊於網路世界呢？</p><a id="more"></a><h4 id="IP-位址"><a href="#IP-位址" class="headerlink" title="IP 位址"></a>IP 位址</h4><p><img src="https://images.pexels.com/photos/826349/pexels-photo-826349.jpeg?cs=srgb&dl=pexels-826349.jpg&fm=jpg" alt="https://images.pexels.com/photos/826349/pexels-photo-826349.jpeg?cs=srgb&amp;dl=pexels-826349.jpg&amp;fm=jpg"></p><p>今天拿起手機上網，手機會先通過 wi-fi、基地台，接著透過地底、海底的光纖電纜來傳輸網路訊號，最終到達用戶需要連上的 server 端，在這過程透過所謂的 IP 位址來找到用戶所搜尋的網站所在的主機，由於 IP 位址是唯一的，所以可以確保用戶知道了 IP 位址，便可以到達想找的設備，而 server 端也可以由發送請求的的設備唯一 IP 位址來找到設備，返回回應。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>這便是 IP 位址所幫助我們的，不過 IP 位址由於由多碼數字構成，通常我們並不習慣記憶使用，我們更常使用比如 <code>google.com</code> 、 <code>ruru.com</code> 等 Domain 名稱，不過如何使用 Domain 來找到唯一位址呢？別擔心，這時候該 Domain 便可以透過 DNS 系統查詢到他所對應的 IP，Google public DNS 便是由 google 所提供的免費域名解析服務器。目前世界的域名、IP 位址等，由 <a href="https://www.icann.org/get-started" target="_blank" rel="noopener">ICANN</a> 進行管理。</p><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2><p>World Wide Web</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/WWW_logo_by_Robert_Cailliau.svg/250px-WWW_logo_by_Robert_Cailliau.svg.png" alt="Internet%20IP%20DNS%20HTTP%20request%20fcd5d8bdc0eb4f4ca3597f0424f94baa/Untitled.png"></p><p>萬維網基於 Internet，萬維網由數以萬計的網頁超文本所構成，每個資源都有其唯一的 URL，通過 HTTP 協議可以使每個用戶得以查閱這些資料，注意他和 Internet 並不相同，他是基於 Internet 所提供的一項服務，也就是我們如今習慣使用的網頁。</p><blockquote><p>Domain 用於標示 IP 位址，一個普通的域名如 XXX.com，URL 則是使用域名來標示特定的網頁，如 <a href="http://www.XXX.com/index.html" target="_blank" rel="noopener">http://www.XXX.com/index.html</a> 使用 XXX.com 作為域名。<a href="https://www.webopedia.com/TERM/D/domain_name.html" target="_blank" rel="noopener">What is Domain Name? Webopedia Definition</a></p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HyperText Transfer Protocol</p><p>HTTP 制定了在萬維網上，client 端請求、server 端回應的一套應答標準。</p><p>我們在上網自輸入網址到進入網頁，會歷經幾項步驟：</p><ol><li>透過 DNS 解析網址成 IP 位址，找到 server</li><li>打開 TCP 連接</li><li>browser 發送請求，送出 HTTP Message，請求 HTTP 資源</li><li>server 發送回應，收到回應 Message</li><li>關閉 TCP 連接或重新請求連接</li></ol><h2 id="HTTP-Message"><a href="#HTTP-Message" class="headerlink" title="HTTP Message"></a>HTTP Message</h2><p>是發送請求以及回應時所附帶的訊息，分為兩種類型，一是請求、二是回應。</p><h4 id="請求範例"><a href="#請求範例" class="headerlink" title="請求範例"></a>請求範例</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p>構成：</p><ul><li>請求的方法</li><li>請求的路徑</li><li>HTTP 版本</li><li>用於附加訊息的 header</li><li>body（不是所有請求都有，有附加資源的 POST 有 body，GET 則無）</li></ul><h4 id="請求方法"><a href="#請求方法" class="headerlink" title="請求方法"></a>請求方法</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener">GET</a><br>GET 方法請求一個指定資源的表示形式. 使用GET的請求應該只被用於獲取數據.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener">HEAD</a><br>HEAD 方法請求一個與 GET 請求的響應相同的響應，但沒有響應體.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener">POST</a><br>POST 方法用於將實體提交到指定的資源，通常導致在服務器上的狀態變化或副作用.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT" target="_blank" rel="noopener">PUT</a><br>PUT 方法用請求有效載荷替換目標資源的所有當前表示。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener">DELETE</a><br>DELETE 方法刪除指定的資源。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT" target="_blank" rel="noopener">CONNECT</a><br>CONNECT 方法建立一個到由目標資源標識的服務器的隧道。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" target="_blank" rel="noopener">OPTIONS</a><br>OPTIONS 方法用於描述目標資源的通信選項。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE" target="_blank" rel="noopener">TRACE</a><br>TRACE 方法沿著到目標資源的路徑執行一個消息環回測試。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH" target="_blank" rel="noopener">PATCH</a><br>PATCH 方法用於對資源應用部分修改。</p><h4 id="回應範例："><a href="#回應範例：" class="headerlink" title="回應範例："></a>回應範例：</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Request URL: https:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</span></span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: <span class="number">200</span></span><br><span class="line">Remote Address: <span class="number">13.35</span><span class="number">.34</span><span class="number">.105</span>:<span class="number">443</span></span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line"></span><br><span class="line"><span class="comment">// response header</span></span><br><span class="line">access-control-allow-origin: *</span><br><span class="line">cache-control: public, max-age=<span class="number">0</span>, s-maxage=<span class="number">300</span></span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-language: zh-CN</span><br><span class="line">content-type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line">date: Sun, <span class="number">05</span> Jul <span class="number">2020</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">53</span> GMT</span><br><span class="line">server: gunicorn/<span class="number">20.0</span><span class="number">.4</span></span><br><span class="line">status: <span class="number">200</span></span><br><span class="line">strict-transport-security: max-age=<span class="number">63072000</span></span><br><span class="line">vary: Accept-Encoding,Cookie</span><br><span class="line">via: <span class="number">1.1</span> <span class="number">2e9008</span>ee05c2ff9176001baad802fed7.cloudfront.net (CloudFront)</span><br><span class="line">x-amz-cf-id: <span class="number">8</span>IK13Gpcn3UkW4ELAV9iH1cHe_9ywxJ085CpDY9r259uMmnvq1nkJw==</span><br><span class="line">x-amz-cf-pop: TPE51-C1</span><br><span class="line">x-cache: Miss <span class="keyword">from</span> cloudfront</span><br><span class="line">x-content-type-options: nosniff</span><br><span class="line">x-frame-options: DENY</span><br><span class="line">x-kuma-revision: <span class="number">1589288</span></span><br><span class="line">x-xss-protection: <span class="number">1</span>; mode=block</span><br></pre></td></tr></table></figure><p>構成：</p><ul><li>HTTP 版本</li><li>狀態碼</li><li>狀態訊息</li><li>HTTP header</li><li>獲取資源的 body</li></ul><h4 id="狀態碼含義"><a href="#狀態碼含義" class="headerlink" title="狀態碼含義"></a>狀態碼含義</h4><p>表示 HTTP 請求是否完成，以及回應狀態。以上狀態碼可以透過 chrome 開發者工具在 Network 查看。</p><p><code>100</code> - <code>199</code> 信息響應，這一類型的狀態碼，代表請求已被接受，需要繼續處理。</p><p><code>200</code> - <code>299</code> 成功響應，這一類型的狀態碼，代表請求已成功被伺服器接收、理解、並接受。</p><ul><li><code>200</code> client 請求已被接受並處理，用來回應 <code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>TRACE</code></li><li><code>201</code> client 請求已被接受並處理，用來回應 <code>PUT</code></li></ul><p><code>300</code> - <code>399</code> 重新定向。這類狀態碼代表需要客戶端採取進一步的操作才能完成請求。通常，這些狀態碼用來重新導向</p><p><code>400</code> - <code>499</code> 客戶端錯誤。這類的狀態碼代表了客戶端看起來可能發生了錯誤，妨礙了伺服器的處理。</p><ul><li><code>403</code> 權限不足被 server 端拒絕</li><li><code>404</code> client 試圖連結的網頁不存在</li></ul><p><code>500</code> - <code>599</code> 服務器錯誤。表示伺服器無法完成明顯有效的請求。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上整理了網頁基礎相關的內容，簡單介紹了 DNS、HTTP ，下次見 ^^</p><p>若有錯誤歡迎指正，謝謝你。</p><hr><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://youtu.be/5o8CwafCxnU" target="_blank" rel="noopener">The Internet: IP Addresses &amp; DNS</a><br><a href="https://www.youtube.com/watch?v=jZOg39v73c4&list=PLuUdFsbOK_8pWzW7KJjbiJ8Ow0cdHlApV&t=0s" target="_blank" rel="noopener">Optical fiber cables, how do they work? | ICT #3</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview" target="_blank" rel="noopener">MDN-HTTP</a><br><a href="https://vincent119.blogspot.com/2008/06/100-continue-client-client-client.html" target="_blank" rel="noopener">HTTP 狀態碼</a></p><h4 id="等待筆記"><a href="#等待筆記" class="headerlink" title="等待筆記"></a>等待筆記</h4><p>常見的 http request <a href="https://blog.miniasp.com/post/2009/01/16/Web-developer-should-know-about-HTTP-Status-Code" target="_blank" rel="noopener">https://blog.miniasp.com/post/2009/01/16/Web-developer-should-know-about-HTTP-Status-Code</a><br>CORS MDN</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Internet-Protocol&quot;&gt;&lt;a href=&quot;#Internet-Protocol&quot; class=&quot;headerlink&quot; title=&quot;Internet Protocol&quot;&gt;&lt;/a&gt;Internet Protocol&lt;/h2&gt;&lt;p&gt;Internet Protocol，是一項網路協議，該協議的重點為 IP 位址，IP 位址是每個在 Internet 中的設備所擁有的唯一位址，通過這個位址我們可以輕鬆的找到其他的設備，不過 IP 位址、Internet 究竟是如何幫助我們在如今便捷的遨遊於網路世界呢？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="internet" scheme="https://github.com/YUN-RU-TSENG/tags/internet/"/>
    
      <category term="web" scheme="https://github.com/YUN-RU-TSENG/tags/web/"/>
    
      <category term="基礎" scheme="https://github.com/YUN-RU-TSENG/tags/%E5%9F%BA%E7%A4%8E/"/>
    
      <category term="DNS" scheme="https://github.com/YUN-RU-TSENG/tags/DNS/"/>
    
      <category term="HTTP request" scheme="https://github.com/YUN-RU-TSENG/tags/HTTP-request/"/>
    
  </entry>
  
  <entry>
    <title>【 Vue 初探 】Vue.js</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/vue%20%E5%88%9D%E6%8E%A2%EF%BC%9AVue.js/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/vue%20%E5%88%9D%E6%8E%A2%EF%BC%9AVue.js/</id>
    <published>2020-07-04T17:19:19.000Z</published>
    <updated>2020-07-08T14:06:31.974Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理 vue 的筆記，也重新看了一遍 vue.org 加深印象以及釐清之前不懂的地方，以下為紀錄筆記，若有錯誤歡迎指正交流，謝謝 😆。</p><a id="more"></a><h5 id="本次內容"><a href="#本次內容" class="headerlink" title="本次內容"></a>本次內容</h5><ol><li>Vue.js 介紹</li><li>聲明式渲染</li><li>條件與循環</li><li>用戶輸入</li></ol><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>Vue.js 最初由 Evan You 開發，在 <a href="https://www.youtube.com/watch?v=OrxmtDw4pVI" target="_blank" rel="noopener">Vue.js : The Documentary</a> 影片中，他提及最初創建 Vue 的想法：</p><blockquote><p><strong>Originally the goal was really just to provide a super simple focused utility, almost just to sync some Dom with some JavaScript objects. That was the original</strong></p></blockquote><p>意思是希望能夠簡單的同步 DOM 與 JS 物件，單純透過這個 JS 物件 data 改變去驅動 DOM 更新，這個概念又稱為 <code>data-driven view</code> 使用資料去驅動畫面改變，我們可以專注在資料上的操作，使得我們的代碼更容易編寫及維護，減少對於 DOM 元素抓取、操作上的關注。</p><p><img src="https://v1.vuejs.org/images/mvvm.png" alt="https://www.notion.so/Vue-Vue-js-Vue-instance-a93ca4a4bc554f1195067a40b09fed12#be7e68ad3bb04045b5e0c50e0e69111d"></p><blockquote><p>這為 Vue V1 版本的 MVVM 示意圖。V1、V0.11、V2.x 在敘述內容上有些更正與修訂， V2.x 文件指出現在 Vue 雖沒有完全遵守 MVVM 模式，但深受其啟發。</p></blockquote><p>這張圖之中的 ViewModel <em>也就是 Vue instance</em> 包含 DOM Listener、Directive 藉此 View（當發生任何事件）、Model（當發生資料改變） 得以透過它來溝通並及時響應。在 Vue 之中  Vue instance 由建構函式透過 <code>new</code> 方式建立而成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;...&#125;)</span><br></pre></td></tr></table></figure><h2 id="如何開始使用"><a href="#如何開始使用" class="headerlink" title="如何開始使用"></a>如何開始使用</h2><p>可以使用下列幾種方式安裝：</p><h4 id="1-直接下載整個-Vue-js"><a href="#1-直接下載整個-Vue-js" class="headerlink" title="1. 直接下載整個 Vue.js"></a>1. 直接下載整個 Vue.js</h4><p>可至官網下載，分為開發版本（有完整錯誤警告）以及生產版本（刪除警告，壓縮過），若是在開發階段，建議使用有完整錯誤警告的開發版本。</p><h4 id="2-CDN"><a href="#2-CDN" class="headerlink" title="2. CDN"></a>2. CDN</h4><p>可使用 CDN 引入，同樣分為開發版本、生產版本。</p><p>開發版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 開發環境版本，包含了有幫助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生產版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生產環境版本，優化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>開發版本可搭配 devtool 調適：</p><p><img src="https://lh3.googleusercontent.com/fCk-pJXAk4oZd-24-PwLqnPnb-X4R3UbDMW-OvAms-1jJuVYS1x3hpbpPSgvNWbwLeSD3m8z=w128-h128-e365" alt="vue"><br>開發版本可以配合官方的開發工具 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en" target="_blank" rel="noopener">vue devTool</a>  進行開發，若是使用生產版本在 Vue 的全局配置對象中， devtool 預設會是 <code>false</code> ，預設模式下無法使用 devtool 開發。（不建議調整為 true 後將生產版本作為開發使用。）</p><h2 id="Declarative-Rendering"><a href="#Declarative-Rendering" class="headerlink" title="Declarative Rendering"></a>Declarative Rendering</h2><p>Vue.js 的核心便是允許採用簡易的模板語法（假如沒有預設 template 則會取所註冊的 element 作為模板），將數據透過聲明 Declarative 的方式渲染進 DOM 系統中，所有在 Vue instance 創建時所包含的數據都是響應式的，一旦數據更新與之聲明相關 DOM 也會相應的更新。</p><h4 id="渲染文字"><a href="#渲染文字" class="headerlink" title="渲染文字"></a>渲染文字</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/VweQYva?editors=1010" target="_blank" rel="noopener">渲染文字</a></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 這個是 element 也就是 vue instance 掛載的元素，透過選擇器選擇，這裡選的是 id="app"</span></span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello 方胖PD!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以透過添加以下程式碼來查看響應式更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello 方胖PD!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line">vm.message = <span class="string">"李PD"</span>; <span class="comment">// 畫面文字也更新了</span></span><br></pre></td></tr></table></figure><div class="danger">注意：一旦創建了 Vue instance（app） 掛載到元素上後，Vue instance 會掛載到剛剛我們所選定要掛載的元素（#app）上，我們不會再直接與 HTML 交互，而是操作該 Vue instance。</div><h4 id="綁定-HTML-attribute"><a href="#綁定-HTML-attribute" class="headerlink" title="綁定 HTML attribute"></a>綁定 HTML attribute</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/qBbxEbd?editors=1010" target="_blank" rel="noopener">綁定 HTML attribute</a></p></blockquote><p>現在知道更改畫面文字的方式了，但是我們可不可以動態的更新 HTML 的 attribute 呢？可以的，這時可以使用 <code>v-bind</code> 來幫這我們做到</p><p><code>v-</code> 開頭指令為 Vue 提供特殊的資料綁定，稱為 <strong>指令</strong> ，例如可以只渲染該元件一次（v-once）、綁定 HTML attribute（v-bind）等。</p><p>我們可以透過 v-bind 將 data 綁定到 HTML attribute 上，下面就綁定了 <code>#app</code> 的 <code>title</code> attribute 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">v-bind:title</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello 方PD!"</span>,</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    text: <span class="string">"今天你有好好搞 i-land 了嗎？"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="條件與循環"><a href="#條件與循環" class="headerlink" title="條件與循環"></a>條件與循環</h2><h4 id="條件"><a href="#條件" class="headerlink" title="條件"></a>條件</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/mdVXdGP" target="_blank" rel="noopener">條件</a></p></blockquote><p>控制一個元素是否會渲染，可以透過 <code>v-if</code> 指令。 <code>v-if</code> 透過 <code>truthy</code>、<code>falsy</code> 判定，當數值為 <code>truthy</code> 則會渲染元素；反之則不渲染。（關於 <code>truthy</code>、<code>falsy</code> 可見 YDKJS）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"false"</span>&gt;</span>你看不見<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="循環"><a href="#循環" class="headerlink" title="循環"></a>循環</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/RwrQNrK" target="_blank" rel="noopener">循環</a></p></blockquote><p>透過使用 <code>v-for</code> 語法，可以渲染 <strong>Array</strong> 到畫面中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app-4"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">"學習 JavaScript"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">"學習 Vue"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">"去看 i-land"</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>當新增資料到數組，會發現列表渲染會隨之更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app4.todos.push(&#123; <span class="attr">text</span>: <span class="string">"新項目"</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="處理用戶輸入"><a href="#處理用戶輸入" class="headerlink" title="處理用戶輸入"></a>處理用戶輸入</h2><p>當用戶有輸入行為，我們希望透過事件監聽與之交互，可以透過 <code>v-on</code> 指令添加事件監聽器，通過它調用位於 Vue instance 中的 methods。</p><h4 id="事件監聽"><a href="#事件監聽" class="headerlink" title="事件監聽"></a>事件監聽</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/NWxyPNY" target="_blank" rel="noopener">事件監聽</a></p></blockquote><p>透過 v-on 我們操作了 DOM 但是沒有真正觸碰到 DOM，我們是使用 Vue instance 去操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"reverseMessage"</span>&gt;</span>反轉消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app-5"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello Vue.js!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>Vue 提供了 v-model 這個語法糖，幫我們綁定表單輸入事件監聽以及 data 資料到表單輸入中，可以實現雙向綁定（當輸入更改數據也隨之更改，反之亦然）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app-6"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello Vue!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上簡單記錄了 <a href="http://vue.org" target="_blank" rel="noopener">Vue.org</a> 介紹 vue.js 內容，介紹了 Vue.js 可以操作的功能，更多的內容會在之後繼續介紹，Bye ^^。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">Vue 官方文件（Ver.0.11 - Ver.2.x）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在整理 vue 的筆記，也重新看了一遍 vue.org 加深印象以及釐清之前不懂的地方，以下為紀錄筆記，若有錯誤歡迎指正交流，謝謝 😆。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="vue" scheme="https://github.com/YUN-RU-TSENG/tags/vue/"/>
    
      <category term="vue.js" scheme="https://github.com/YUN-RU-TSENG/tags/vue-js/"/>
    
      <category term="note" scheme="https://github.com/YUN-RU-TSENG/tags/note/"/>
    
      <category term="front-end" scheme="https://github.com/YUN-RU-TSENG/tags/front-end/"/>
    
      <category term="vue.org" scheme="https://github.com/YUN-RU-TSENG/tags/vue-org/"/>
    
  </entry>
  
  <entry>
    <title>Mikrokosmos</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/06/Mikrokosmos/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/06/Mikrokosmos/</id>
    <published>2020-06-28T03:04:33.000Z</published>
    <updated>2020-07-06T08:43:29.324Z</updated>
    
    <content type="html"><![CDATA[<p>Mikrokosmos</p><p>reset 2020-06-28 03:04:33.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mikrokosmos&lt;/p&gt;
&lt;p&gt;reset 2020-06-28 03:04:33.&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="reset" scheme="https://github.com/YUN-RU-TSENG/tags/reset/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruru-Front-End-Blog</title>
  
  <subtitle>Ruru Front-End-note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/YUN-RU-TSENG/"/>
  <updated>2020-07-17T05:59:07.932Z</updated>
  <id>https://github.com/YUN-RU-TSENG/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【 YDKJS 】 Object (筆記版)</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/%E3%80%90YDKJS%E3%80%91%E7%89%A9%E4%BB%B6-Object/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/%E3%80%90YDKJS%E3%80%91%E7%89%A9%E4%BB%B6-Object/</id>
    <published>2020-07-16T16:04:05.000Z</published>
    <updated>2020-07-17T05:59:07.932Z</updated>
    
    <content type="html"><![CDATA[<h4 id="🎙🎙🎙-nbsp-nbsp-閱讀須知"><a href="#🎙🎙🎙-nbsp-nbsp-閱讀須知" class="headerlink" title="🎙🎙🎙 &nbsp; &nbsp; 閱讀須知"></a>🎙🎙🎙 &nbsp; &nbsp; 閱讀須知</h4><p>本文為筆者閱讀 <strong>You Don’t Know JavaScript</strong> 系列時的心得，有鑒於日益嚴重的健忘問題，也沒有錢可以買銀杏護體，便開始了 <del>大抄</del> 筆記整理的行動 🏃，主要會對書中內容進行心得整理、紀錄一些當下遇到的神秘問題。歡迎一起討論交流，有任何錯誤也請各位大大不吝鞭笞，小菜雞不慎感激 🙇。</p><p><a href="https://www.animatedimages.org/cat-frogs-198.htm" target="_blank" rel="noopener"><img src="https://www.animatedimages.org/data/media/198/animated-frog-image-0204.gif" border="0" alt="animated-frog-image-0204" /></a></p><hr/><h1 id="🔖-nbsp-Object，你好"><a href="#🔖-nbsp-Object，你好" class="headerlink" title="🔖&nbsp; Object，你好"></a>🔖&nbsp; <code>Object</code>，你好</h1><p>Javascript 中，<code>Object</code>依照來源可以區分為：</p><img src="./screenshot 2020-07-16 20.58.24.jpg"/><ol><li>宿主物件：由宿主環境提供的<code>Object</code> <em>object supplied by the host environment to complete the execution environment of ECMAScript</em></li><li>原生物件：由 ECMAScript 實現提供，不包含宿主環境定義的<code>Object</code>。 <em>object in an ECMAScript implementation whose semantics are fully defined by this specification rather than by the host environment</em></li></ol><ul><li>包含內置物件：Date、String …</li></ul><h2 id="宿主物件"><a href="#宿主物件" class="headerlink" title="宿主物件"></a>宿主物件</h2><p>剛剛有說到 <strong>宿主物件</strong> 是由 <strong>宿主環境</strong> 提供的物件，那麼什麼是 <strong>宿主環境</strong> 呢？</p><p>我們現在所撰寫的 JavaScript ，需要透過宿主環境（瀏覽器、Node）執行，以瀏覽器來說：比如我們常用的 Chrome、Safari 等，都是可以使 JavaScript 運行的環境，這便被稱為 <strong>宿主環境</strong>，一個運作 Javascript 腳本的環境，而宿主環境如今也不僅僅只有瀏覽器，Node 也可以作為宿主環境，大大提升了 Javascript 可被應用的場合。</p><h4 id="宿主環境中的-Object："><a href="#宿主環境中的-Object：" class="headerlink" title="宿主環境中的 Object："></a>宿主環境中的 <code>Object</code>：</h4><p>規範中 <a href="http://ecma-international.org/ecma-262/5.1/#sec-4.1" target="_blank" rel="noopener">4.1</a> 有如此提到：</p><blockquote><p>A web browser provides an ECMAScript host environment for client-side computation including, for instance, objects that represent windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, and input/output. Further, the host environment provides a means to attach scripting code to events such as change of focus, page and image loading, unloading, error and abort, selection, form submission, and mouse actions. Scripting code appears within the HTML and the displayed page is a combination of user interface elements and fixed and computed text and images. The scripting code is reactive to user interaction and there is no need for a main program.</p></blockquote><p>上面的意思提到了瀏覽器環境提供的宿主物件，可以理解為，宿主環境通常會藉由提供特別的 <code>Object</code> 使 JavaScript 可以藉由操作這些 <code>Object</code> 得以使用宿主環境所提供的功能。</p><p>以瀏覽器來說：</p><p>諸如我們常用的 <code>document</code>、<code>window</code>、<code>cookie</code> 等瀏覽器中提供中的這些 <code>Object</code> 便是我們常會用到的宿主物件，使得 JavaScript 可以藉由操作這些宿主物件處理瀏覽器所提供的功能，諸如點擊按鈕後更換主題色、暫存網頁資料。</p><p>JavaScript 在瀏覽器中可以使用瀏覽器所提供的 Web api，來進行常用的 DOM、Cookie 等操作，與 Event 連用，便可以與用戶交互，舉例來說以下為常見的瀏覽器 <strong>宿主物件</strong>：</p><ul><li>☝&nbsp; document 可以藉由它所提供的諸多屬性，操作有關 Dom 的相關功能。</li><li>☝&nbsp; console 你知道的。</li><li>☝&nbsp; localStorage 可以用來操作瀏覽器的本地存取功能，常見如 sessionStorage、localStorage。</li></ul><img src="./screenshot 2020-07-16 17.11.07.jpg"/><p>可以想像 Javascript 在瀏覽器中運行，便可以使用該宿主環境所提供的 <code>Object</code>。<br><br/></p><img src="./screenshot 2020-07-16 18.14.09.jpg"/>若是在其他宿主環境，便會有不同的宿主物件可以使用。<hr/><h2 id="原生物件："><a href="#原生物件：" class="headerlink" title="原生物件："></a>原生物件：</h2><p>說回 YDKJS 的內容，原生物件便是由 ECMAScript 所定義的物件，平時我們使用 <code>{}</code> 字面值、<code>new Object()</code> 等方式創建的物件便是原生物件的一種，而內置物件也屬於原生物件，如 Date、String 等屬於此範疇。</p><h4 id="建立物件的方法一共有兩種："><a href="#建立物件的方法一共有兩種：" class="headerlink" title="建立物件的方法一共有兩種："></a>建立物件的方法一共有兩種：</h4><img src="./screenshot 2020-07-16 23.42.11.jpg"/><ol><li><code>{}</code> 字面值</li><li>new Object()</li></ol><p>字面值建立物件更為直觀，可以清晰地看見物件結構：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">"Henry"</span>,</span><br><span class="line">  sex: <span class="string">"man"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建構式建立物件則有一項明顯的缺點，便是得要 <span style="color: #fc766a; font-weight: 700">一個一個新增數值</span>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 新增 name</span></span><br><span class="line">a.name = <span class="string">"Henry"</span>;</span><br><span class="line"><span class="comment">// 新增 man</span></span><br><span class="line">a.sex = <span class="string">"man"</span>;</span><br></pre></td></tr></table></figure><h4 id="那麼，new-Object-以及-都可以生成物件，到底該使用哪個呢？"><a href="#那麼，new-Object-以及-都可以生成物件，到底該使用哪個呢？" class="headerlink" title="那麼，new Object 以及 {} 都可以生成物件，到底該使用哪個呢？"></a>那麼，new Object 以及 {} 都可以生成物件，到底該使用哪個呢？</h4><p>答案當然是 <code>{}</code> ，因為 <code>{}</code> 更為直觀。除此之外，根據這一篇 stackoverflow 所提到的問題:</p><p><a href="https://stackoverflow.com/questions/4597926/what-is-the-difference-between-new-object-and-object-literal-notation" target="_blank" rel="noopener">What is the difference between <code>new Object()</code> and object literal notation?</a></p><p>其實可以發現近兩者在執行速率上有些許的差異：</p><p>使用 <code>console.time</code> 來比較 <code>{}</code> 以及 <code>new Object</code> 生成物件，以下為比較生成 <code>100000000</code> 個 <code>{}</code> 以及 <code>10000000</code> 個 <code>new Object()</code> 的差異：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"using&#123;&#125;"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"using&#123;&#125;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"using new"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"using new"</span>);</span><br></pre></td></tr></table></figure><p>以下為執行結果：</p><ol><li>{} 需要 1095 毫秒</li><li>new Object 需要 1205 毫秒</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Testing Object:</span><br><span class="line">using&#123;&#125;: 1095.606201171875ms</span><br><span class="line">using new: 1205.525146484375ms</span><br></pre></td></tr></table></figure><p>根據 <a href="https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array" target="_blank" rel="noopener">Why is arr = [] faster than arr = new Array?</a> 的解釋，可以看到有人從 token 編譯方向去比較兩者的差異，使用 <code>{}</code> 可以減少需要花費額外的 CPU 來確定 new Object 的操作，不過針對這段，由於對於編譯代碼的不熟悉，於是暫時筆記下來，之後再回顧檢討。</p><blockquote><p>結論： <code>{}</code> 可以更直觀、更快捷的生成新的物件</p></blockquote><p><strong>💊 &nbsp; 等待筆記、閱讀的相關資源</strong><br><a href="https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array" target="_blank" rel="noopener">Why is arr = [] faster than arr = new Array?</a></p><hr><h4 id="補充編譯-bytecode-比較差異的方法："><a href="#補充編譯-bytecode-比較差異的方法：" class="headerlink" title="補充編譯 bytecode 比較差異的方法："></a>補充編譯 bytecode 比較差異的方法：</h4><p>建立 <code>{}.js</code> 以及 <code>constructor.js</code> 兩者分別裝載了以下內容：</p><h4 id="包含"><a href="#包含" class="headerlink" title="{} 包含"></a>{} 包含</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="建構式-包含"><a href="#建構式-包含" class="headerlink" title="建構式 包含"></a>建構式 包含</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>使用 <strong>node</strong> <code>node --print-bytecode 要編譯的檔案.js &gt; 要輸出的 bytecode 結果.txt</code> 查看兩者的編譯結果，結果上兩者並非完全相同，使用 diff 比較兩者是有差異的。不過這一部份目前不確定的很多，首先 bytecode 我不太會看，所以先當成一個疑惑，留著以後深入筆記。</p><p><strong>💊 &nbsp; 等待筆記、閱讀的相關資源</strong><br><a href="https://github.com/aszx87410/blog/issues/54">從 V8 bytecode 看 let 與 var 的效能問題<br>#54</a></p><hr><h2 id="內置物件："><a href="#內置物件：" class="headerlink" title="內置物件："></a>內置物件：</h2><p>剛介紹完了原生物件，Javascript 原生物件中還包含了內置物件，在 Javascript 開始執行後，便會存在於環境中可供使用，其中下列常見的基本類別有各自對應的內置物件名稱：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><p>以上的內置物件皆為函式，可以透過建構函式方式呼叫，由於 JS 原型繼承的設計，每個構造器函式的 prototype 將被生成的物件隱式的引用，這部分之後會詳細說明，不過可以先看下段 ECMA 中的介紹：</p><blockquote><p>Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s “prototype” property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the prototype chain. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on</p></blockquote><h4 id="Javascript-中的建構子："><a href="#Javascript-中的建構子：" class="headerlink" title="Javascript 中的建構子："></a>Javascript 中的建構子：</h4><p>簡單來說，Javascript 沒有 class 的設計，由於當初只是一個簡單設計的腳本語言，所以設計者設計了建構子（擁有 prototype 的函式，透過 new 表達式生成對象）讓生成的物件得以隱性的引用連結建構式的 prototype，便可以達成屬性共享、原型繼承的功能。</p><img src="./screenshot 2020-07-17 11.28.44.jpg"/><p>以上圖來說，建構子生成 A1、A2、A3 三個物件，每個物件都有各自的屬性：</p><p>黃線代表原型繼承，建構子本身的 <code>p1</code>、<code>p2</code> 對於 <code>prototype</code> 以及 <code>A1</code>、<code>A2</code>、<code>A3</code> 是不可見的，然後位於 <code>prototype</code> 中的屬性（只要 <code>A1</code>、<code>A2</code>、<code>A3</code> 不含有該屬性名，不然就會以 <code>A1</code>、<code>A2</code>、<code>A3</code> 本身的該屬性名優先）可以被 <code>A1</code>、<code>A2</code>、<code>A3</code> 共享。</p><p><strong>注意，建構子和 <code>prototype</code> 是沒有隱性繼承的關係的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建構子</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="function"><span class="keyword">function</span>(<span class="params">a1, a2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a1 = a1;</span><br><span class="line">    <span class="keyword">this</span>.a2 = a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建構子的 prototype</span></span><br><span class="line">p.prototype = &#123;</span><br><span class="line">    method1: <span class="string">'...'</span>,</span><br><span class="line">    method2: <span class="string">'...'</span>,</span><br><span class="line">    method3: <span class="string">'...'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 new p 建構的物件</span></span><br><span class="line"><span class="keyword">var</span> A1 = <span class="keyword">new</span> p(<span class="number">12</span>, <span class="number">22</span>)</span><br><span class="line"><span class="keyword">var</span> A2 = <span class="keyword">new</span> p(<span class="number">3</span>, <span class="number">33</span>)</span><br><span class="line"><span class="keyword">var</span> A3 = <span class="keyword">new</span> p(<span class="number">5</span>, <span class="number">67</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這些物件繼承了 p.prototype，指向 prototype 位址</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(A1) === p.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(A2) === p.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(A3) === p.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">A1.method1 <span class="comment">// '...'</span></span><br><span class="line">p.method1 <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>可以實際執行一次程式碼。記得 <code>p</code> 建構子不會繼承自己的 <code>prototype</code> 屬性，所以 <code>p.method1</code> 並沒有值。</p><h2 id="回到內置物件"><a href="#回到內置物件" class="headerlink" title="回到內置物件"></a>回到內置物件</h2><p>看過上述建構子介紹後，相信大家可以猜想到透過建構子的特性，Javascript 的內置建構子也有它所定義的 <code>prototype</code>，並且乘載著好用的屬性，例如 String 建構子的 prototype ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">anchor: ƒ anchor()</span><br><span class="line">big: ƒ big()</span><br><span class="line">blink: ƒ blink()</span><br><span class="line">bold: ƒ bold()</span><br><span class="line">charAt: ƒ charAt()</span><br><span class="line">charCodeAt: ƒ charCodeAt()</span><br><span class="line">codePointAt: ƒ codePointAt()</span><br><span class="line">concat: ƒ concat()</span><br><span class="line"><span class="keyword">constructor</span>: ƒ String()</span><br><span class="line">endsWith: ƒ endsWith()</span><br><span class="line">fixed: ƒ fixed()</span><br><span class="line">fontcolor: ƒ fontcolor()</span><br><span class="line">fontsize: ƒ fontsize()</span><br><span class="line">includes: ƒ includes()</span><br><span class="line">indexOf: ƒ indexOf()</span><br><span class="line">italics: ƒ italics()</span><br><span class="line">lastIndexOf: ƒ lastIndexOf()</span><br><span class="line">length: 0</span><br><span class="line">link: ƒ link()</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>包含如上許多可用的功能，可以查詢 charcode、可以更換特定文字，只要透過 <code>new String()</code> 生成的物件，都可以因為原型繼承，可以直接使用這些方法。但是，平時我們時常使用的 <code>&#39;Alice&#39;</code> 等字串也可以使用 <code>&#39;Alice&#39;.chartat()</code> 等方法，相信你一定不陌生，這是由於 javascript coercion（轉型），在使用以下方法時會使用內部方法 toObject(V) 將字串 <code>&#39;Alice&#39;</code> 轉型成為 <code>String 物件</code>，有人稱這過程為 <code>boxing</code> 或是此時物件為 <code>wrapper object</code> 但是規範中沒有出現相關關鍵詞，其為一個討論此概念的說法。</p><p>下面來看看轉型時我們自規範可以窺見什麼</p><h4 id="6-2-3-1"><a href="#6-2-3-1" class="headerlink" title="6.2.3.1"></a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-getvalue" target="_blank" rel="noopener">6.2.3.1</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. ReturnIfAbrupt(V).</span><br><span class="line">2. If Type(V) is not Reference, return V.</span><br><span class="line">3. Let base be GetBase(V).</span><br><span class="line">4. If IsUnresolvableReference(V), throw a ReferenceError exception.</span><br><span class="line">5. If IsPropertyReference(V), then.</span><br><span class="line">    a.If HasPrimitiveBase(V) is true, then.</span><br><span class="line">        i. Assert: In this case, base will never be null or undefined.</span><br><span class="line">        ii. Let base be ToObject(base).</span><br><span class="line">    b.Return base.[[Get]](GetReferencedName(V), GetThisValue(V)).</span><br><span class="line">6. Else base must be an Environment Record,</span><br><span class="line">    a.Return base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).</span><br></pre></td></tr></table></figure><p>由此方法我們可以看見，當出現 <code>&#39;Alice&#39;</code>.charat() 時，Alice 的 reference type（此為 javascript 內部屬性，為一個抽象 instance，當 identify 解析、屬性訪問過程中會創建，base 為引用基值、name 為引用名稱、strict 表示是否為嚴格模式：</p><h4 id="reference-示意"><a href="#reference-示意" class="headerlink" title="reference 示意"></a>reference 示意</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base: &#96;&#39;Alice&#39;&#96;</span><br><span class="line">name: charat</span><br><span class="line">strice: false</span><br></pre></td></tr></table></figure><p>套用到上述 a ii. 可以看見當 base 數值為非物件的基本型別，此時會將 base 值透過 toObject(base) 轉型，並且返回轉型後查找到的屬性，故在此便可以使用基本型別來使用內部屬性。</p><h4 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h4><p><a href="http://perfectionkills.com/know-thy-reference/" target="_blank" rel="noopener">reference</a><br><a href="https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/" target="_blank" rel="noopener">The Secret Life of JavaScript Primitives</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;🎙🎙🎙-nbsp-nbsp-閱讀須知&quot;&gt;&lt;a href=&quot;#🎙🎙🎙-nbsp-nbsp-閱讀須知&quot; class=&quot;headerlink&quot; title=&quot;🎙🎙🎙 &amp;nbsp; &amp;nbsp; 閱讀須知&quot;&gt;&lt;/a&gt;🎙🎙🎙 &amp;nbsp; &amp;nbsp
      
    
    </summary>
    
    
    
      <category term="scope" scheme="https://github.com/YUN-RU-TSENG/tags/scope/"/>
    
      <category term="javascript" scheme="https://github.com/YUN-RU-TSENG/tags/javascript/"/>
    
      <category term="instance" scheme="https://github.com/YUN-RU-TSENG/tags/instance/"/>
    
      <category term="YDKJavaScript" scheme="https://github.com/YUN-RU-TSENG/tags/YDKJavaScript/"/>
    
      <category term="You Don&#39;t Know JavaScript" scheme="https://github.com/YUN-RU-TSENG/tags/You-Don-t-Know-JavaScript/"/>
    
      <category term="Object" scheme="https://github.com/YUN-RU-TSENG/tags/Object/"/>
    
      <category term="new" scheme="https://github.com/YUN-RU-TSENG/tags/new/"/>
    
      <category term="get" scheme="https://github.com/YUN-RU-TSENG/tags/get/"/>
    
      <category term="set" scheme="https://github.com/YUN-RU-TSENG/tags/set/"/>
    
      <category term="reference" scheme="https://github.com/YUN-RU-TSENG/tags/reference/"/>
    
  </entry>
  
  <entry>
    <title>【 Vue 初探 】Vue instance</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/%E3%80%90Vue-%E5%88%9D%E6%8E%A2%E3%80%91Vue-instance/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/%E3%80%90Vue-%E5%88%9D%E6%8E%A2%E3%80%91Vue-instance/</id>
    <published>2020-07-11T18:33:42.000Z</published>
    <updated>2020-07-12T04:08:33.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本節重點"><a href="#本節重點" class="headerlink" title="本節重點"></a>本節重點</h2><ul><li>Vue instance 是什麼？該如何使用？</li><li>life cycle 生命週期介紹？</li></ul><h1 id="Vue-instance"><a href="#Vue-instance" class="headerlink" title="Vue instance"></a>Vue instance</h1><p>上章節的內容提及 Vue 最初源自 MVVM 設計，在初始版官方文件中提到（V0.11）：</p><p><strong>M</strong> - 由 JS 物件、基本資料物件構成。<br><strong>V</strong> - 由 Vue instance 所控制的 DOM，通常為我們所編譯的 <code>template</code>。<br><strong>VM</strong> - 同步 V 與 M 的 ViewModel 由 Vue instance 擔任。</p><p>透過 Vue instance，可以同步 View 以及 Model。這一章節會討論到如何建立 Vue instance，以及如何使用。</p><h2 id="Vue-instance-建立方式："><a href="#Vue-instance-建立方式：" class="headerlink" title="Vue instance 建立方式："></a>Vue instance 建立方式：</h2><p>根 Vue instance 透過 <code>new Vue</code> 建構式生成，該方式所填入的 <code>options</code> 物件才能使用 <code>el</code> 選項。在 Vue 中每一個組件也都是一個 instance，透過嵌套的方式層層疊疊的形成組件樹。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">/* options */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Vue-instance-options-object"><a href="#Vue-instance-options-object" class="headerlink" title="Vue instance options object"></a>Vue instance options object</h2><blockquote><p>可查閱官方文件 <a href="https://cn.vuejs.org/v2/api/#el" target="_blank" rel="noopener">vuejs.org</a></p></blockquote><p>每個 Vue instance 可以在創建時傳入 <code>options</code> 物件，為一選項物件包含 Vue instance 掛載的 DOM 位置、Data、mixin、生命週期回調訊息等，常用的選項屬性有：</p><h4 id="🧤-options-DOM：el"><a href="#🧤-options-DOM：el" class="headerlink" title="🧤 options/DOM：el"></a>🧤 options/DOM：el</h4><p>類型：String | Element<br>限制：只在使用 <code>new</code> 建構式創建的 instance 創建時有效<br>用途：提供一個實際存在的 DOM 元素作為 Vue instance 掛載的目標，可以填入 CSS 選擇器、HTMLElement。所選擇的 el 元素在掛載後會完全被替換，因此不推薦掛在 <code>html</code> 或 <code>body</code> 上。</p><h4 id="掛載範例："><a href="#掛載範例：" class="headerlink" title="掛載範例："></a>掛載範例：</h4><p>以下方例子來說，<code>div.app</code> 是 Vue instance 掛載的目標，將被 <code>p</code> 模板所替換，所以不建議使用 <code>html</code>、<code>body</code> 作為 Vue instance 掛載目標，這兩個元素將被取代帶來非預期的渲染結果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>instance 將掛載的元件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: `<span class="tag">&lt;<span class="name">p</span>&gt;</span>被替換上去的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span>`,</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  vm.$mount(<span class="string">".app"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最初為：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>instance 將掛載的元件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue instance 掛載後，<code>div.app</code> 被替換：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>被替換上去的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="若是不在-root-instance-的-options-中填入-el"><a href="#若是不在-root-instance-的-options-中填入-el" class="headerlink" title="若是不在 root instance 的 options 中填入 el"></a>若是不在 root instance 的 options 中填入 el</h4><p>若是不填入 el，Vue instance 將不會掛載直到手動掛載執行 <a href="https://cn.vuejs.org/v2/api/?#vm-mount" target="_blank" rel="noopener">vm.$mount</a>(‘要掛載的元素’) 後，才會掛載到 el 上。反之，一旦寫了 el，Vue instance 將直接被掛載。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: `<span class="tag">&lt;<span class="name">p</span>&gt;</span>被替換上去的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span>`,</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  <span class="comment">// 執行到 created 步驟</span></span></span><br><span class="line"><span class="actionscript">  vm.$mount(<span class="string">".app"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 開始執行 mounted 步驟</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要觀看 mount 掛載調用的生命週期執行，可使用以下方式，可以觀察到載手動掛載前生命週期鉤子調用到 <code>created</code> vm.$mount 後便將模板掛載到目標元素上，生命週期鉤子調用到 <code>mounted</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: `<span class="tag">&lt;<span class="name">p</span>&gt;</span>被替換上去的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span>`,</span></span></span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"beforeCreate -&gt; beforeCreate"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"在實例初始化之後，資料觀測 (data observer) 和 event/watcher 事件設定之前被呼叫。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"created -&gt; created"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"在實例建立完成後被立即呼叫。在這一步，實例已完成以下的設定：資料觀測 (data observer)，property 和方法的運算，watch/event 事件callback。然而，掛載階段還沒開始，$el property 目前尚不可用。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"beforeMount -&gt; beforeMount"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"在掛載開始之前被呼叫：相關的 render 函數首次被呼叫。"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"mounted -&gt; mounted"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"實例被掛載後呼叫，這時 el 被新建立的 vm.$el 替換了。如果根實例掛載到了一個檔案內的元素上，當 mounted 被呼叫時 vm.$el 也在檔案內。注意 mounted 不會保證所有的子組件也都一起被掛載。如果你希望等到整個視圖都渲染完畢，可以在 mounted 內部使用 vm.$nextTick："</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"beforeUpdate -&gt; beforeUpdate"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"資料更新時呼叫，發生在虛擬 DOM 打補丁之前。這裡適合在更新之前訪問現有的 DOM，比如手動移除已添加的事件監聽器。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"updated -&gt; updated"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"由於資料更改導致的虛擬 DOM 重新渲染和打補丁，在這之後會呼叫該鉤子。當這個鉤子被呼叫時，組件 DOM 已經更新，所以你現在可以執行依賴於 DOM 的操作。然而在大多數情況下，你應該避免在此期間更改狀態。如果要相應狀態改變，通常最好使用計算屬性或 watcher 取而代之。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"beforeDestroy -&gt; beforeDestroy"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"實例銷毀之前呼叫。在這一步，實例仍然完全可用。"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"destroyed -&gt; destroyed"</span>, destroyed);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">        <span class="string">"實例銷毀後呼叫。該鉤子被呼叫後，對應 Vue 實例的所有指令都被解綁，所有的事件監聽器被移除，所有的子實例也都被銷毀。"</span></span></span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  <span class="comment">// 執行到 created 步驟</span></span></span><br><span class="line"><span class="actionscript">  vm.$mount(<span class="string">".app"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 開始執行 mounted 步驟</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="danger">在 instance 掛載後，元素可以透過 vm.$el 訪問。如果存在該 `el` 選項，則 Vue instance 立即進行編譯，否則需要透過 vm.$mount() 綁定。如果 template 和 render fun 皆不存在，則掛載 DOM 元素的 HTML 會被取出當作模板。</div><h2 id="生命週期"><a href="#生命週期" class="headerlink" title="生命週期"></a>生命週期</h2><p>Vue instance 創建時，會歷經一系列的初始化過程，如設定數據監聽、將模板掛載到目標元素等，在這些步驟執行過程中，你可以時間在特定時間調用 callback 函數去在特定時段添加特定的程式碼。</p><table><thead><tr><th>lifecycle hook</th><th>內容</th><th></th></tr></thead><tbody><tr><td>beforeCreate</td><td>在實例初始化之後，數據觀測 (data observer) 和 event/watcher 事件配置之前被調用。</td><td></td></tr><tr><td>created</td><td>在實例創建完成後被立即調用。在這一步，實例已完成以下的配置：數據觀測 (data observer)，property 和方法的運算，watch/event 事件回調。然而，掛載階段還沒開始， $el property 目前尚不可用。</td><td></td></tr><tr><td>beforeMount</td><td>在掛載開始之前被調用：相關的 render 函數首次被調用。 該鉤子在服務器端渲染期間不被調用。</td><td></td></tr><tr><td>mounted</td><td>實例被掛載後調用，這時 el 被新創建的 vm.$el 替換了。如果根實例掛載到了一個文檔內的元素上，當 mounted 被調用時 vm.$el 也在文檔內。 注意 mounted 不會保證所有的子組件也都一起被掛載。如果你希望等到整個視圖都渲染完畢，可以在 mounted 內部使用 vm.$nextTick</td><td></td></tr><tr><td>beforeUpdate</td><td>數據更新時調用，發生在虛擬 DOM 打補丁之前。這裡適合在更新之前訪問現有的 DOM，比如手動移除已添加的事件監聽器。 該鉤子在服務器端渲染期間不被調用，因為只有初次渲染會在服務端進行。</td><td></td></tr><tr><td>updated</td><td>由於數據更改導致的虛擬 DOM 重新渲染和打補丁，在這之後會調用該鉤子。 當這個鉤子被調用時，組件 DOM 已經更新，所以你現在可以執行依賴於 DOM 的操作。然而在大多數情況下，你應該避免在此期間更改狀態。如果要相應狀態改變，通常最好使用計算屬性或 watcher 取而代之。 注意 updated 不會保證所有的子組件也都一起被重繪。如果你希望等到整個視圖都重繪完畢，可以在 updated 裡使用 vm.$nextTick</td><td></td></tr><tr><td>beforeDestroy</td><td>實例銷毀之前調用。在這一步，實例仍然完全可用。</td><td></td></tr><tr><td>destroyed</td><td>實例銷毀後調用。該鉤子被調用後，對應 Vue 實例的所有指令都被解綁，所有的事件監聽器被移除，所有的子實例也都被銷毀。</td><td></td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">".app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">          num: 123,</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="handlebars"><span class="xml">        template: `<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; num &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>`,</span></span></span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeCreate -&gt; beforeCreate"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"在實例初始化之後，資料觀測 (data observer) 和 event/watcher 事件設定之前被呼叫。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        created() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"created -&gt; created"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"在實例建立完成後被立即呼叫。在這一步，實例已完成以下的設定：資料觀測 (data observer)，property 和方法的運算，watch/event 事件callback。然而，掛載階段還沒開始，$el property 目前尚不可用。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeMount -&gt; beforeMount"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"在掛載開始之前被呼叫：相關的 render 函數首次被呼叫。"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"mounted -&gt; mounted"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"實例被掛載後呼叫，這時 el 被新建立的 vm.$el 替換了。如果根實例掛載到了一個檔案內的元素上，當 mounted 被呼叫時 vm.$el 也在檔案內。注意 mounted 不會保證所有的子組件也都一起被掛載。如果你希望等到整個視圖都渲染完畢，可以在 mounted 內部使用 vm.$nextTick："</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeUpdate -&gt; beforeUpdate"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"資料更新時呼叫，發生在虛擬 DOM 打補丁之前。這裡適合在更新之前訪問現有的 DOM，比如手動移除已添加的事件監聽器。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"updated -&gt; updated"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"由於資料更改導致的虛擬 DOM 重新渲染和打補丁，在這之後會呼叫該鉤子。當這個鉤子被呼叫時，組件 DOM 已經更新，所以你現在可以執行依賴於 DOM 的操作。然而在大多數情況下，你應該避免在此期間更改狀態。如果要相應狀態改變，通常最好使用計算屬性或 watcher 取而代之。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"beforeDestroy -&gt; beforeDestroy"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"實例銷毀之前呼叫。在這一步，實例仍然完全可用。"</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"destroyed -&gt; destroyed"</span>, destroyed);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="actionscript">            <span class="string">"實例銷毀後呼叫。該鉤子被呼叫後，對應 Vue 實例的所有指令都被解綁，所有的事件監聽器被移除，所有的子實例也都被銷毀。"</span></span></span><br><span class="line">          );</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"$el"</span>, <span class="keyword">this</span>.$el, <span class="string">"$data"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue%20instance%20ec8d6e67b59e4767ac372188e1417cdd/Untitled.png"></p><p>等待筆記：<br><a href="https://011.vuejs.org/guide/components.html" target="_blank" rel="noopener">Vue.extend()</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本節重點&quot;&gt;&lt;a href=&quot;#本節重點&quot; class=&quot;headerlink&quot; title=&quot;本節重點&quot;&gt;&lt;/a&gt;本節重點&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Vue instance 是什麼？該如何使用？&lt;/li&gt;
&lt;li&gt;life cycle 生命週期介紹？&lt;/li&gt;
      
    
    </summary>
    
    
    
      <category term="vue" scheme="https://github.com/YUN-RU-TSENG/tags/vue/"/>
    
      <category term="vue Instance" scheme="https://github.com/YUN-RU-TSENG/tags/vue-Instance/"/>
    
      <category term="instance" scheme="https://github.com/YUN-RU-TSENG/tags/instance/"/>
    
      <category term="hook" scheme="https://github.com/YUN-RU-TSENG/tags/hook/"/>
    
      <category term="lifecycle" scheme="https://github.com/YUN-RU-TSENG/tags/lifecycle/"/>
    
      <category term="生命週期" scheme="https://github.com/YUN-RU-TSENG/tags/%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F/"/>
    
      <category term="實體" scheme="https://github.com/YUN-RU-TSENG/tags/%E5%AF%A6%E9%AB%94/"/>
    
      <category term="Vue 實體" scheme="https://github.com/YUN-RU-TSENG/tags/Vue-%E5%AF%A6%E9%AB%94/"/>
    
  </entry>
  
  <entry>
    <title>【 YDKJS 】什麼是 Scope？</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/YDKJS-%E4%BB%80%E9%BA%BC%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/YDKJS-%E4%BB%80%E9%BA%BC%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F/</id>
    <published>2020-07-06T16:16:41.000Z</published>
    <updated>2020-07-06T16:06:38.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>資料來源：<a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN">YDKJS 作用域與閉包 - 第一章</a></p></blockquote><h4 id="本篇提及："><a href="#本篇提及：" class="headerlink" title="本篇提及："></a>本篇提及：</h4><ul><li>scope</li><li>編譯器</li><li>引擎</li><li>RHS、LHS</li></ul><p>Scope 提供查找、儲存變數的一組規則，編譯器、引擎都會使用這組規則，在編譯器經歷詞法分析、解析後，便會將解析成抽象語法樹的 AST 轉化成機器代碼：</p><a id="more"></a><p>可以使用 node.js 查看 bytecode</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --print-bytecode ooxxoo.js</span><br></pre></td></tr></table></figure><h2 id="以實例查看-scope-與編譯器、引擎的互動"><a href="#以實例查看-scope-與編譯器、引擎的互動" class="headerlink" title="以實例查看 scope 與編譯器、引擎的互動"></a>以實例查看 scope 與編譯器、引擎的互動</h2><blockquote><p>以 <code>var S = 12</code>  為範例：</p></blockquote><p>在編譯器經歷詞法分析、解析後，在編譯上述代碼成機器碼時，會進行以下的動作：</p><ol><li>查看 <code>var S</code> 是否已存在當前 scope集合中，若是有則忽略該聲明；若是無則會讓 scope 在該 scope 集合中新增 <code>S</code> 變數。</li><li>編譯器生成 <code>S = 12</code> 的機器碼，以提供引擎稍後執行賦值的動作。引擎在執行該程式碼時，也會詢問 scope 中是否存在此變數</li></ol><h4 id="引擎詢問-scope-分為-LHS、-RHS"><a href="#引擎詢問-scope-分為-LHS、-RHS" class="headerlink" title="引擎詢問 scope 分為 LHS、 RHS"></a>引擎詢問 scope 分為 <code>LHS</code>、 <code>RHS</code></h4><p><code>LHS</code> 變數在左側，查詢是否存在，並且執行賦值操作。（不一定在左測，想成賦予數值的目標）</p><ul><li>當找尋不到時，且並非 <code>strict</code> 模式，會在全域中新增該變數。</li><li>當找尋不到時，且為 <code>strict</code> 模式，會拋出 <code>ReferenceError</code></li></ul><p><code>RHS</code> 變數在右側，查詢是否存在，並且返回其值。（不一定在右側，想成查找數值的源頭）</p><ul><li>當找尋不到時，會丟出 <code>ReferenceError</code></li><li>當找到但卻拿著該數值做不正確的行為（如拿基本型別去跑函式）則會丟出 <code>TypeError</code></li></ul><p><code>RHS</code></p><p>以下會發現變數 <code>a</code> 在右側，經過查詢得到其數值後便會被返回。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p><code>LHS</code></p><p>會查找該變數存在與否，並賦予新值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">22</span></span><br></pre></td></tr></table></figure><h5 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">foo</span> (<span class="params"> a </span>)  </span>&#123;</span><br><span class="line"><span class="built_in">console</span> . log (  a  ) ;  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo (  <span class="number">2</span>  ) ;</span><br></pre></td></tr></table></figure><p>scope 與引擎的交互：</p><ol><li><code>RHS</code> 查詢 foo 函式，並執行</li><li><code>LHS</code> 將 a 參數賦予數值 2</li><li><code>RHS</code> 查詢 console 是否存在</li><li><code>RHS</code> 查詢 a，並且 console 打印</li></ol><blockquote><p>注意：其中的 foo 函式並非 <code>var foo = function(){...}</code> 賦值的概念，此函數聲明一開始在編譯器生成時，就已經將函式賦予該變數。</p></blockquote><h2 id="巢狀-scope"><a href="#巢狀-scope" class="headerlink" title="巢狀 scope"></a>巢狀 scope</h2><p>就像程式碼被巢狀在另一堆程式碼中，作用域也是巢狀存在於其他作用域中的，如果該作用域找不到變數，引擎便會向外尋找。</p><p>像是 console 若在 foo 內找尋不著，便會向全域尋找。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">foo</span> (<span class="params"> a </span>)  </span>&#123;</span><br><span class="line"><span class="built_in">console</span> . log (  a  ) ;  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo (  <span class="number">2</span>  ) ;</span><br></pre></td></tr></table></figure><p>查找 console 時，若找到最頂層仍無（只是舉例，當然不會找不到），則會視是否有嚴格模式來決定是要給予錯誤或是將該變數新增到全域中。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;資料來源：&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN&quot;&gt;YDKJS 作用域與閉包 - 第一章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;本篇提及：&quot;&gt;&lt;a href=&quot;#本篇提及：&quot; class=&quot;headerlink&quot; title=&quot;本篇提及：&quot;&gt;&lt;/a&gt;本篇提及：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;scope&lt;/li&gt;
&lt;li&gt;編譯器&lt;/li&gt;
&lt;li&gt;引擎&lt;/li&gt;
&lt;li&gt;RHS、LHS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scope 提供查找、儲存變數的一組規則，編譯器、引擎都會使用這組規則，在編譯器經歷詞法分析、解析後，便會將解析成抽象語法樹的 AST 轉化成機器代碼：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="scope" scheme="https://github.com/YUN-RU-TSENG/tags/scope/"/>
    
      <category term="javascript" scheme="https://github.com/YUN-RU-TSENG/tags/javascript/"/>
    
      <category term="YDKJS" scheme="https://github.com/YUN-RU-TSENG/tags/YDKJS/"/>
    
  </entry>
  
  <entry>
    <title>【 網路基礎 】IP、DNS、HTTP request</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/%E5%88%9D%E6%8E%A2-Internet-%E5%9F%BA%E7%A4%8E%EF%BC%9AIP%E3%80%81DNS%E3%80%81HTTP-request/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/%E5%88%9D%E6%8E%A2-Internet-%E5%9F%BA%E7%A4%8E%EF%BC%9AIP%E3%80%81DNS%E3%80%81HTTP-request/</id>
    <published>2020-07-06T01:37:41.000Z</published>
    <updated>2020-07-06T08:42:57.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Internet-Protocol"><a href="#Internet-Protocol" class="headerlink" title="Internet Protocol"></a>Internet Protocol</h2><p>Internet Protocol，是一項網路協議，該協議的重點為 IP 位址，IP 位址是每個在 Internet 中的設備所擁有的唯一位址，通過這個位址我們可以輕鬆的找到其他的設備，不過 IP 位址、Internet 究竟是如何幫助我們在如今便捷的遨遊於網路世界呢？</p><a id="more"></a><h4 id="IP-位址"><a href="#IP-位址" class="headerlink" title="IP 位址"></a>IP 位址</h4><p><img src="https://images.pexels.com/photos/826349/pexels-photo-826349.jpeg?cs=srgb&dl=pexels-826349.jpg&fm=jpg" alt="https://images.pexels.com/photos/826349/pexels-photo-826349.jpeg?cs=srgb&amp;dl=pexels-826349.jpg&amp;fm=jpg"></p><p>今天拿起手機上網，手機會先通過 wi-fi、基地台，接著透過地底、海底的光纖電纜來傳輸網路訊號，最終到達用戶需要連上的 server 端，在這過程透過所謂的 IP 位址來找到用戶所搜尋的網站所在的主機，由於 IP 位址是唯一的，所以可以確保用戶知道了 IP 位址，便可以到達想找的設備，而 server 端也可以由發送請求的的設備唯一 IP 位址來找到設備，返回回應。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>這便是 IP 位址所幫助我們的，不過 IP 位址由於由多碼數字構成，通常我們並不習慣記憶使用，我們更常使用比如 <code>google.com</code> 、 <code>ruru.com</code> 等 Domain 名稱，不過如何使用 Domain 來找到唯一位址呢？別擔心，這時候該 Domain 便可以透過 DNS 系統查詢到他所對應的 IP，Google public DNS 便是由 google 所提供的免費域名解析服務器。目前世界的域名、IP 位址等，由 <a href="https://www.icann.org/get-started" target="_blank" rel="noopener">ICANN</a> 進行管理。</p><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2><p>World Wide Web</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/WWW_logo_by_Robert_Cailliau.svg/250px-WWW_logo_by_Robert_Cailliau.svg.png" alt="Internet%20IP%20DNS%20HTTP%20request%20fcd5d8bdc0eb4f4ca3597f0424f94baa/Untitled.png"></p><p>萬維網基於 Internet，萬維網由數以萬計的網頁超文本所構成，每個資源都有其唯一的 URL，通過 HTTP 協議可以使每個用戶得以查閱這些資料，注意他和 Internet 並不相同，他是基於 Internet 所提供的一項服務，也就是我們如今習慣使用的網頁。</p><blockquote><p>Domain 用於標示 IP 位址，一個普通的域名如 XXX.com，URL 則是使用域名來標示特定的網頁，如 <a href="http://www.XXX.com/index.html" target="_blank" rel="noopener">http://www.XXX.com/index.html</a> 使用 XXX.com 作為域名。<a href="https://www.webopedia.com/TERM/D/domain_name.html" target="_blank" rel="noopener">What is Domain Name? Webopedia Definition</a></p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HyperText Transfer Protocol</p><p>HTTP 制定了在萬維網上，client 端請求、server 端回應的一套應答標準。</p><p>我們在上網自輸入網址到進入網頁，會歷經幾項步驟：</p><ol><li>透過 DNS 解析網址成 IP 位址，找到 server</li><li>打開 TCP 連接</li><li>browser 發送請求，送出 HTTP Message，請求 HTTP 資源</li><li>server 發送回應，收到回應 Message</li><li>關閉 TCP 連接或重新請求連接</li></ol><h2 id="HTTP-Message"><a href="#HTTP-Message" class="headerlink" title="HTTP Message"></a>HTTP Message</h2><p>是發送請求以及回應時所附帶的訊息，分為兩種類型，一是請求、二是回應。</p><h4 id="請求範例"><a href="#請求範例" class="headerlink" title="請求範例"></a>請求範例</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p>構成：</p><ul><li>請求的方法</li><li>請求的路徑</li><li>HTTP 版本</li><li>用於附加訊息的 header</li><li>body（不是所有請求都有，有附加資源的 POST 有 body，GET 則無）</li></ul><h4 id="請求方法"><a href="#請求方法" class="headerlink" title="請求方法"></a>請求方法</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener">GET</a><br>GET 方法請求一個指定資源的表示形式. 使用GET的請求應該只被用於獲取數據.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener">HEAD</a><br>HEAD 方法請求一個與 GET 請求的響應相同的響應，但沒有響應體.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener">POST</a><br>POST 方法用於將實體提交到指定的資源，通常導致在服務器上的狀態變化或副作用.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT" target="_blank" rel="noopener">PUT</a><br>PUT 方法用請求有效載荷替換目標資源的所有當前表示。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener">DELETE</a><br>DELETE 方法刪除指定的資源。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT" target="_blank" rel="noopener">CONNECT</a><br>CONNECT 方法建立一個到由目標資源標識的服務器的隧道。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" target="_blank" rel="noopener">OPTIONS</a><br>OPTIONS 方法用於描述目標資源的通信選項。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE" target="_blank" rel="noopener">TRACE</a><br>TRACE 方法沿著到目標資源的路徑執行一個消息環回測試。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH" target="_blank" rel="noopener">PATCH</a><br>PATCH 方法用於對資源應用部分修改。</p><h4 id="回應範例："><a href="#回應範例：" class="headerlink" title="回應範例："></a>回應範例：</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Request URL: https:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</span></span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: <span class="number">200</span></span><br><span class="line">Remote Address: <span class="number">13.35</span><span class="number">.34</span><span class="number">.105</span>:<span class="number">443</span></span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line"></span><br><span class="line"><span class="comment">// response header</span></span><br><span class="line">access-control-allow-origin: *</span><br><span class="line">cache-control: public, max-age=<span class="number">0</span>, s-maxage=<span class="number">300</span></span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-language: zh-CN</span><br><span class="line">content-type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line">date: Sun, <span class="number">05</span> Jul <span class="number">2020</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">53</span> GMT</span><br><span class="line">server: gunicorn/<span class="number">20.0</span><span class="number">.4</span></span><br><span class="line">status: <span class="number">200</span></span><br><span class="line">strict-transport-security: max-age=<span class="number">63072000</span></span><br><span class="line">vary: Accept-Encoding,Cookie</span><br><span class="line">via: <span class="number">1.1</span> <span class="number">2e9008</span>ee05c2ff9176001baad802fed7.cloudfront.net (CloudFront)</span><br><span class="line">x-amz-cf-id: <span class="number">8</span>IK13Gpcn3UkW4ELAV9iH1cHe_9ywxJ085CpDY9r259uMmnvq1nkJw==</span><br><span class="line">x-amz-cf-pop: TPE51-C1</span><br><span class="line">x-cache: Miss <span class="keyword">from</span> cloudfront</span><br><span class="line">x-content-type-options: nosniff</span><br><span class="line">x-frame-options: DENY</span><br><span class="line">x-kuma-revision: <span class="number">1589288</span></span><br><span class="line">x-xss-protection: <span class="number">1</span>; mode=block</span><br></pre></td></tr></table></figure><p>構成：</p><ul><li>HTTP 版本</li><li>狀態碼</li><li>狀態訊息</li><li>HTTP header</li><li>獲取資源的 body</li></ul><h4 id="狀態碼含義"><a href="#狀態碼含義" class="headerlink" title="狀態碼含義"></a>狀態碼含義</h4><p>表示 HTTP 請求是否完成，以及回應狀態。以上狀態碼可以透過 chrome 開發者工具在 Network 查看。</p><p><code>100</code> - <code>199</code> 信息響應，這一類型的狀態碼，代表請求已被接受，需要繼續處理。</p><p><code>200</code> - <code>299</code> 成功響應，這一類型的狀態碼，代表請求已成功被伺服器接收、理解、並接受。</p><ul><li><code>200</code> client 請求已被接受並處理，用來回應 <code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>TRACE</code></li><li><code>201</code> client 請求已被接受並處理，用來回應 <code>PUT</code></li></ul><p><code>300</code> - <code>399</code> 重新定向。這類狀態碼代表需要客戶端採取進一步的操作才能完成請求。通常，這些狀態碼用來重新導向</p><p><code>400</code> - <code>499</code> 客戶端錯誤。這類的狀態碼代表了客戶端看起來可能發生了錯誤，妨礙了伺服器的處理。</p><ul><li><code>403</code> 權限不足被 server 端拒絕</li><li><code>404</code> client 試圖連結的網頁不存在</li></ul><p><code>500</code> - <code>599</code> 服務器錯誤。表示伺服器無法完成明顯有效的請求。</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上整理了網頁基礎相關的內容，簡單介紹了 DNS、HTTP ，下次見 ^^</p><p>若有錯誤歡迎指正，謝謝你。</p><hr><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://youtu.be/5o8CwafCxnU" target="_blank" rel="noopener">The Internet: IP Addresses &amp; DNS</a><br><a href="https://www.youtube.com/watch?v=jZOg39v73c4&list=PLuUdFsbOK_8pWzW7KJjbiJ8Ow0cdHlApV&t=0s" target="_blank" rel="noopener">Optical fiber cables, how do they work? | ICT #3</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview" target="_blank" rel="noopener">MDN-HTTP</a><br><a href="https://vincent119.blogspot.com/2008/06/100-continue-client-client-client.html" target="_blank" rel="noopener">HTTP 狀態碼</a></p><h4 id="等待筆記"><a href="#等待筆記" class="headerlink" title="等待筆記"></a>等待筆記</h4><p>常見的 http request <a href="https://blog.miniasp.com/post/2009/01/16/Web-developer-should-know-about-HTTP-Status-Code" target="_blank" rel="noopener">https://blog.miniasp.com/post/2009/01/16/Web-developer-should-know-about-HTTP-Status-Code</a><br>CORS MDN</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Internet-Protocol&quot;&gt;&lt;a href=&quot;#Internet-Protocol&quot; class=&quot;headerlink&quot; title=&quot;Internet Protocol&quot;&gt;&lt;/a&gt;Internet Protocol&lt;/h2&gt;&lt;p&gt;Internet Protocol，是一項網路協議，該協議的重點為 IP 位址，IP 位址是每個在 Internet 中的設備所擁有的唯一位址，通過這個位址我們可以輕鬆的找到其他的設備，不過 IP 位址、Internet 究竟是如何幫助我們在如今便捷的遨遊於網路世界呢？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="internet" scheme="https://github.com/YUN-RU-TSENG/tags/internet/"/>
    
      <category term="web" scheme="https://github.com/YUN-RU-TSENG/tags/web/"/>
    
      <category term="基礎" scheme="https://github.com/YUN-RU-TSENG/tags/%E5%9F%BA%E7%A4%8E/"/>
    
      <category term="DNS" scheme="https://github.com/YUN-RU-TSENG/tags/DNS/"/>
    
      <category term="HTTP request" scheme="https://github.com/YUN-RU-TSENG/tags/HTTP-request/"/>
    
  </entry>
  
  <entry>
    <title>【 Vue 初探 】Vue.js</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/07/vue%20%E5%88%9D%E6%8E%A2%EF%BC%9AVue.js/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/07/vue%20%E5%88%9D%E6%8E%A2%EF%BC%9AVue.js/</id>
    <published>2020-07-04T17:19:19.000Z</published>
    <updated>2020-07-08T14:06:31.974Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理 vue 的筆記，也重新看了一遍 vue.org 加深印象以及釐清之前不懂的地方，以下為紀錄筆記，若有錯誤歡迎指正交流，謝謝 😆。</p><a id="more"></a><h5 id="本次內容"><a href="#本次內容" class="headerlink" title="本次內容"></a>本次內容</h5><ol><li>Vue.js 介紹</li><li>聲明式渲染</li><li>條件與循環</li><li>用戶輸入</li></ol><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>Vue.js 最初由 Evan You 開發，在 <a href="https://www.youtube.com/watch?v=OrxmtDw4pVI" target="_blank" rel="noopener">Vue.js : The Documentary</a> 影片中，他提及最初創建 Vue 的想法：</p><blockquote><p><strong>Originally the goal was really just to provide a super simple focused utility, almost just to sync some Dom with some JavaScript objects. That was the original</strong></p></blockquote><p>意思是希望能夠簡單的同步 DOM 與 JS 物件，單純透過這個 JS 物件 data 改變去驅動 DOM 更新，這個概念又稱為 <code>data-driven view</code> 使用資料去驅動畫面改變，我們可以專注在資料上的操作，使得我們的代碼更容易編寫及維護，減少對於 DOM 元素抓取、操作上的關注。</p><p><img src="https://v1.vuejs.org/images/mvvm.png" alt="https://www.notion.so/Vue-Vue-js-Vue-instance-a93ca4a4bc554f1195067a40b09fed12#be7e68ad3bb04045b5e0c50e0e69111d"></p><blockquote><p>這為 Vue V1 版本的 MVVM 示意圖。V1、V0.11、V2.x 在敘述內容上有些更正與修訂， V2.x 文件指出現在 Vue 雖沒有完全遵守 MVVM 模式，但深受其啟發。</p></blockquote><p>這張圖之中的 ViewModel <em>也就是 Vue instance</em> 包含 DOM Listener、Directive 藉此 View（當發生任何事件）、Model（當發生資料改變） 得以透過它來溝通並及時響應。在 Vue 之中  Vue instance 由建構函式透過 <code>new</code> 方式建立而成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;...&#125;)</span><br></pre></td></tr></table></figure><h2 id="如何開始使用"><a href="#如何開始使用" class="headerlink" title="如何開始使用"></a>如何開始使用</h2><p>可以使用下列幾種方式安裝：</p><h4 id="1-直接下載整個-Vue-js"><a href="#1-直接下載整個-Vue-js" class="headerlink" title="1. 直接下載整個 Vue.js"></a>1. 直接下載整個 Vue.js</h4><p>可至官網下載，分為開發版本（有完整錯誤警告）以及生產版本（刪除警告，壓縮過），若是在開發階段，建議使用有完整錯誤警告的開發版本。</p><h4 id="2-CDN"><a href="#2-CDN" class="headerlink" title="2. CDN"></a>2. CDN</h4><p>可使用 CDN 引入，同樣分為開發版本、生產版本。</p><p>開發版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 開發環境版本，包含了有幫助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生產版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生產環境版本，優化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>開發版本可搭配 devtool 調適：</p><p><img src="https://lh3.googleusercontent.com/fCk-pJXAk4oZd-24-PwLqnPnb-X4R3UbDMW-OvAms-1jJuVYS1x3hpbpPSgvNWbwLeSD3m8z=w128-h128-e365" alt="vue"><br>開發版本可以配合官方的開發工具 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en" target="_blank" rel="noopener">vue devTool</a>  進行開發，若是使用生產版本在 Vue 的全局配置對象中， devtool 預設會是 <code>false</code> ，預設模式下無法使用 devtool 開發。（不建議調整為 true 後將生產版本作為開發使用。）</p><h2 id="Declarative-Rendering"><a href="#Declarative-Rendering" class="headerlink" title="Declarative Rendering"></a>Declarative Rendering</h2><p>Vue.js 的核心便是允許採用簡易的模板語法（假如沒有預設 template 則會取所註冊的 element 作為模板），將數據透過聲明 Declarative 的方式渲染進 DOM 系統中，所有在 Vue instance 創建時所包含的數據都是響應式的，一旦數據更新與之聲明相關 DOM 也會相應的更新。</p><h4 id="渲染文字"><a href="#渲染文字" class="headerlink" title="渲染文字"></a>渲染文字</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/VweQYva?editors=1010" target="_blank" rel="noopener">渲染文字</a></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 這個是 element 也就是 vue instance 掛載的元素，透過選擇器選擇，這裡選的是 id="app"</span></span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello 方胖PD!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以透過添加以下程式碼來查看響應式更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello 方胖PD!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line">vm.message = <span class="string">"李PD"</span>; <span class="comment">// 畫面文字也更新了</span></span><br></pre></td></tr></table></figure><div class="danger">注意：一旦創建了 Vue instance（app） 掛載到元素上後，Vue instance 會掛載到剛剛我們所選定要掛載的元素（#app）上，我們不會再直接與 HTML 交互，而是操作該 Vue instance。</div><h4 id="綁定-HTML-attribute"><a href="#綁定-HTML-attribute" class="headerlink" title="綁定 HTML attribute"></a>綁定 HTML attribute</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/qBbxEbd?editors=1010" target="_blank" rel="noopener">綁定 HTML attribute</a></p></blockquote><p>現在知道更改畫面文字的方式了，但是我們可不可以動態的更新 HTML 的 attribute 呢？可以的，這時可以使用 <code>v-bind</code> 來幫這我們做到</p><p><code>v-</code> 開頭指令為 Vue 提供特殊的資料綁定，稱為 <strong>指令</strong> ，例如可以只渲染該元件一次（v-once）、綁定 HTML attribute（v-bind）等。</p><p>我們可以透過 v-bind 將 data 綁定到 HTML attribute 上，下面就綁定了 <code>#app</code> 的 <code>title</code> attribute 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">v-bind:title</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello 方PD!"</span>,</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    text: <span class="string">"今天你有好好搞 i-land 了嗎？"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="條件與循環"><a href="#條件與循環" class="headerlink" title="條件與循環"></a>條件與循環</h2><h4 id="條件"><a href="#條件" class="headerlink" title="條件"></a>條件</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/mdVXdGP" target="_blank" rel="noopener">條件</a></p></blockquote><p>控制一個元素是否會渲染，可以透過 <code>v-if</code> 指令。 <code>v-if</code> 透過 <code>truthy</code>、<code>falsy</code> 判定，當數值為 <code>truthy</code> 則會渲染元素；反之則不渲染。（關於 <code>truthy</code>、<code>falsy</code> 可見 YDKJS）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"false"</span>&gt;</span>你看不見<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="循環"><a href="#循環" class="headerlink" title="循環"></a>循環</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/RwrQNrK" target="_blank" rel="noopener">循環</a></p></blockquote><p>透過使用 <code>v-for</code> 語法，可以渲染 <strong>Array</strong> 到畫面中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app-4"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">"學習 JavaScript"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">"學習 Vue"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">"去看 i-land"</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>當新增資料到數組，會發現列表渲染會隨之更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app4.todos.push(&#123; <span class="attr">text</span>: <span class="string">"新項目"</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="處理用戶輸入"><a href="#處理用戶輸入" class="headerlink" title="處理用戶輸入"></a>處理用戶輸入</h2><p>當用戶有輸入行為，我們希望透過事件監聽與之交互，可以透過 <code>v-on</code> 指令添加事件監聽器，通過它調用位於 Vue instance 中的 methods。</p><h4 id="事件監聽"><a href="#事件監聽" class="headerlink" title="事件監聽"></a>事件監聽</h4><blockquote><p>可點擊前往範例 <a href="https://codepen.io/yunru1230/pen/NWxyPNY" target="_blank" rel="noopener">事件監聽</a></p></blockquote><p>透過 v-on 我們操作了 DOM 但是沒有真正觸碰到 DOM，我們是使用 Vue instance 去操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"reverseMessage"</span>&gt;</span>反轉消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app-5"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello Vue.js!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>Vue 提供了 v-model 這個語法糖，幫我們綁定表單輸入事件監聽以及 data 資料到表單輸入中，可以實現雙向綁定（當輸入更改數據也隨之更改，反之亦然）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app-6"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello Vue!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上簡單記錄了 <a href="http://vue.org" target="_blank" rel="noopener">Vue.org</a> 介紹 vue.js 內容，介紹了 Vue.js 可以操作的功能，更多的內容會在之後繼續介紹，Bye ^^。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">Vue 官方文件（Ver.0.11 - Ver.2.x）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在整理 vue 的筆記，也重新看了一遍 vue.org 加深印象以及釐清之前不懂的地方，以下為紀錄筆記，若有錯誤歡迎指正交流，謝謝 😆。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="vue" scheme="https://github.com/YUN-RU-TSENG/tags/vue/"/>
    
      <category term="vue.js" scheme="https://github.com/YUN-RU-TSENG/tags/vue-js/"/>
    
      <category term="note" scheme="https://github.com/YUN-RU-TSENG/tags/note/"/>
    
      <category term="front-end" scheme="https://github.com/YUN-RU-TSENG/tags/front-end/"/>
    
      <category term="vue.org" scheme="https://github.com/YUN-RU-TSENG/tags/vue-org/"/>
    
  </entry>
  
  <entry>
    <title>Mikrokosmos</title>
    <link href="https://github.com/YUN-RU-TSENG/archives/2020/06/Mikrokosmos/"/>
    <id>https://github.com/YUN-RU-TSENG/archives/2020/06/Mikrokosmos/</id>
    <published>2020-06-28T03:04:33.000Z</published>
    <updated>2020-07-06T08:43:29.324Z</updated>
    
    <content type="html"><![CDATA[<p>Mikrokosmos</p><p>reset 2020-06-28 03:04:33.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mikrokosmos&lt;/p&gt;
&lt;p&gt;reset 2020-06-28 03:04:33.&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="reset" scheme="https://github.com/YUN-RU-TSENG/tags/reset/"/>
    
  </entry>
  
</feed>

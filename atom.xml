<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruru-Front-End-Blog</title>
  
  <subtitle>Ruru Front-End-note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-12T13:53:37.893Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>YDKJS 非同步 lesson1 筆記 上</title>
    <link href="http://yoursite.com/archives/2020/06/YDKJS%20%20lesson1%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%AD%86%E8%A8%98%20%E4%B8%8A/"/>
    <id>http://yoursite.com/archives/2020/06/YDKJS%20%20lesson1%20%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%AD%86%E8%A8%98%20%E4%B8%8A/</id>
    <published>2020-06-12T21:50:08.000Z</published>
    <updated>2020-06-12T13:53:37.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YDKJS-Lesson1-非同步與性能-筆記"><a href="#YDKJS-Lesson1-非同步與性能-筆記" class="headerlink" title="YDKJS Lesson1 非同步與性能 筆記"></a>YDKJS Lesson1 非同步與性能 筆記</h1><h1 id="現在與稍後："><a href="#現在與稍後：" class="headerlink" title="現在與稍後："></a>現在與稍後：</h1><p>JS 非同步的重點在於，如何表達、操作 <strong>現在</strong> 與 <strong>稍後</strong> 要執行的程式碼之間的確切執行順序與關係。</p><ul><li>例如設定三個非同步，之間如何保障執行順序。</li><li>同步與非同步之間的執行順序。</li></ul><h2 id="涉及方法："><a href="#涉及方法：" class="headerlink" title="涉及方法："></a>涉及方法：</h2><ol><li>callback</li><li>promise</li><li>async await</li><li>generate</li></ol><hr><h1 id="區塊中-chunks-的程式："><a href="#區塊中-chunks-的程式：" class="headerlink" title="區塊中 chunks 的程式："></a>區塊中 chunks 的程式：</h1><ul><li><p>chunk 定義資料：</p><p>  <a href="https://www.google.com/search?safe=active&sxsrf=ALeKk033p1qCsUoakSBUwyyYvapbw_WkwA%3A1591939593059&ei=CRLjXvuBA5mIr7wPyeidyAM&q=what+is+chunk+in+programming&oq=what+is+chunk+in+programming&gs_lcp=CgZwc3ktYWIQAzIECAAQRzIECAAQRzIECAAQRzIECAAQRzIECAAQRzIECAAQRzIECAAQRzIECAAQR1AAWABgxaQFaABwAXgAgAEAiAEAkgEAmAEAqgEHZ3dzLXdpeg&sclient=psy-ab&ved=0ahUKEwi7qsqPxfvpAhUZxIsBHUl0BzkQ4dUDCAw&uact=5" target="_blank" rel="noopener">what is chunk in programming - Google Search</a></p></li></ul><p>操作 <strong>現在</strong> 與 <strong>稍後</strong> 執行的程式碼區塊，通常會是 <code>function</code> 。</p><h2 id="非同步初探"><a href="#非同步初探" class="headerlink" title="非同步初探"></a>非同步初探</h2><p>非同步若是與同步共同執行會產生的錯誤如下。</p><p>考慮這段代碼：</p><p>因為在 <code>ajax</code> 部分不會阻塞，所以 data 會是 <code>undefined</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax(..)是某個包中任意的 Ajax 函數</span></span><br><span class="line"><span class="keyword">var</span> data = ajax( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"><span class="built_in">console</span>.log( data );</span><br><span class="line"><span class="comment">// 噢！`data` 一般不會有 Ajax 的結果</span></span><br><span class="line"><span class="comment">// 這是因為他不會按照預期的組塞</span></span><br></pre></td></tr></table></figure><p><strong>如何解決？</strong></p><p>使用 callback 是確保非同步執行順序，非同步執行後再執行 <code>callback</code> 是處理順序的簡單方式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax(..) 是某個包中任意的Ajax函數</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span> <span class="title">myCallbackFunction</span>(<span class="params">data</span>)</span>&#123;<span class="built_in">console</span>.log( data ); <span class="comment">// Yay, 我得到了一些`data`!</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p><strong>警告：</strong> 你可能聽說過發起同步的Ajax請求是可能的。雖然在技術上是這樣的，但你永遠，永遠不應該在任何情況下這樣做，因為它將鎖定瀏覽器的UI（按鈕，選單，捲動條，等等）而且阻止使用者與任何東西互動。這是一個非常差勁的主意，你應當永遠迴避它。<br><strong>阻塞絕對不是個好方法</strong></p><h2 id="非同步初探-2："><a href="#非同步初探-2：" class="headerlink" title="非同步初探 2："></a>非同步初探 2：</h2><p>以下為非同步範例，展示將同步非同步以兩個代碼塊 chunk（函式） 包裹，透過 callback 方式確保執行順序。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">later</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">answer = answer * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"Meaning of life:"</span>, answer );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> answer = now();</span><br><span class="line">setTimeout( later, <span class="number">1000</span> ); <span class="comment">// Meaning of life: 42</span></span><br></pre></td></tr></table></figure><p>現在：（同步）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">later</span>(<span class="params"></span>) </span>&#123; .. &#125;</span><br><span class="line"><span class="keyword">var</span> answer = now();</span><br><span class="line">setTimeout( later, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure><p>稍後：（非同步）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">answer = answer * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"Meaning of life:"</span>, answer );</span><br></pre></td></tr></table></figure><h3 id="非同步-控制台？"><a href="#非同步-控制台？" class="headerlink" title="非同步 控制台？"></a><strong><code>非同步</code> 控制台？</strong></h3><ul><li>規範定義：<a href="https://console.spec.whatwg.org/" target="_blank" rel="noopener">https://console.spec.whatwg.org/</a></li><li>補充好的 console 使用方式：<a href="https://developers.google.com/web/tools/chrome-devtools/console" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/console</a></li><li>chrome 瀏覽器有哪些功能 api 便於使用：<a href="https://developers.google.com/web/tools/chrome-devtools/console/utilities" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/console/utilities</a></li></ul><p>console 為一組 web api，提供對瀏覽器控制台的使用，其中 console.log 對於目前的內容打印出一組快照，但不確定是同步或是非同步，各家實現不同，規範尚無明確定義，其原因可能與 I/O 阻塞等多項理由相關，保險方式乃為使用 <code>JSON.stringfy()</code> 進行進行、或是瀏覽器本身的 <code>debugger</code>。</p><p>console.log() ：</p><ul><li>宿主環境所提供</li><li><strong>&gt;&gt;&gt;&gt;&gt;&gt;<em>到底是同步還是非同步，各家實作不同，規範目前沒有查到相關資訊。</em></strong></li><li><strong>火狐、chrome 目前的 console.log 為參考 reference</strong> — 出自 MDN <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Console/log</a></li></ul><p>基本型別：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bef'</span>,number);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'befJSON'</span>,<span class="built_in">JSON</span>.stringify(number));</span><br><span class="line">number++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aft'</span>,number)</span><br></pre></td></tr></table></figure><p>物件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bef'</span>,obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'befJSON'</span>,<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">obj.name = <span class="string">'A'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aft'</span>,obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aftJSON'</span>,<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure><h1 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h1><ul><li>概念來源影片：<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=1237s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=1237s</a></li></ul><p>JS 引擎中不涉及非同步的概念，之所以能夠進行非同步，是由於與宿主環境提供的 API 進行配合，例如使用 <code>setTimeout</code> 、 <code>eventListener</code> 等等。</p><h2 id="call-stack"><a href="#call-stack" class="headerlink" title="call stack"></a>call stack</h2><ul><li>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack</a></li></ul><p>追蹤函數執行流的一種機制。當執行環境中調用了多個函數函數時，通過這種機制，我們能夠追蹤到哪個函數正在執行，執行的函數體中又調用了哪個函數。，之所以可以做到非同步來源於 宿主環境 eventloop 對於事件的指派。</p><p>範例：</p><p>stack : p - s - m : m - s - p</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiple</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiple(n , n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(square(n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printSquare(<span class="number">12</span>) <span class="comment">// 144</span></span><br></pre></td></tr></table></figure><h2 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h2><ul><li>規範定義：To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop, which is unique to that agent.</li><li>規範網址：<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/webappapis.html#event-loops</a></li></ul><p>透過對 call stack 和 tick 的監聽，當 call stack 空，便將目前位於 tick 的 callback 推入，JS 引擎也因不斷的被安排事件，可以做到非同步。</p><h3 id="事件循環的實際範例："><a href="#事件循環的實際範例：" class="headerlink" title="事件循環的實際範例："></a>事件循環的實際範例：</h3><ul><li>使用此網站查看：<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYXN5bmNBcnJheTIoYXJyLCBjYikgewogICAgYXJyLmZvckVhY2goZnVuY3Rpb24oKXsKICAgIHNldFRpbWVvdXQoY2IsIDIwMDApCiAgICB9KQp9CgpbMSwyLDMsNF0uZm9yRWFjaChmdW5jdGlvbihpKXsKICAgIGNvbnNvbGUubG9nKCdzeW5jJyxpKQogICAgZGVsYXkoKQp9KQoKYXN5bmNBcnJheTIoWzExLDIyLDMzLDQ0XSwgZnVuY3Rpb24oaSl7CiAgICBjb25zb2xlLmxvZygnYXN5bmMnLGkpCiAgICBkZWxheSgpCn0p" target="_blank" rel="noopener">http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYXN5bmNBcnJheTIoYXJyLCBjYikgewogICAgYXJyLmZvckVhY2goZnVuY3Rpb24oKXsKICAgIHNldFRpbWVvdXQoY2IsIDIwMDApCiAgICB9KQp9CgpbMSwyLDMsNF0uZm9yRWFjaChmdW5jdGlvbihpKXsKICAgIGNvbnNvbGUubG9nKCdzeW5jJyxpKQogICAgZGVsYXkoKQp9KQoKYXN5bmNBcnJheTIoWzExLDIyLDMzLDQ0XSwgZnVuY3Rpb24oaSl7CiAgICBjb25zb2xlLmxvZygnYXN5bmMnLGkpCiAgICBkZWxheSgpCn0p</a>!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D</li></ul><p>使用 <code>setTimeout</code> 時，eventloop 和 call stack 的執行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 我們提到了“直到最近”，暗示著ES6改變了事件輪詢佇列在何處被管理的性質。這主要是一個正式的技術規範，ES6現在明確地指出了事件輪詢應當如何工作，這意味著它技術上屬於JS引擎應當關心的範疇內，而不僅僅是 <em>宿主環境</em>。這麼做的一個主要原因是為了引入ES6的Promises（我們將在第三章討論），因為人們需要有能力對事件輪詢佇列的排隊操作進行直接，細粒度的控制（參見“協作”一節中關於<code>setTimeout(..0)</code>的討論）。</p><h1 id="並行（多線程）"><a href="#並行（多線程）" class="headerlink" title="並行（多線程）"></a>並行（多線程）</h1><ul><li>需要補充的教學資料：<a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif" target="_blank" rel="noopener">https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif</a></li><li>需要補充的教學資料：<a href="https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/" target="_blank" rel="noopener">https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/</a></li></ul><p>比較單線程非同步、多線程同步差異，目前已知的差別在於多線程共享記憶體，同時進行，所以在程式執行的時候會產生較多的可能性；反之單線程非同步不共享記憶體，需要考慮的是執行時間順序對於節果的影響。</p><p><a href="https://www.notion.so/6d8efe5d05544596a9e38db6fa216196" target="_blank" rel="noopener">單線程與多線程比較</a></p><p>考慮這段代碼：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">a = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ajax(..) 是一個給定的庫中的隨意Ajax函數</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure><h2 id="單線程非同步："><a href="#單線程非同步：" class="headerlink" title="單線程非同步："></a>單線程非同步：</h2><p>在JavaScript的單執行緒行為下，如果<code>foo()</code>在<code>bar()</code>之前執行，結果<code>a</code>是<code>42</code>，但如果<code>bar()</code>在<code>foo()</code>之前執行，結果<code>a</code>將是<code>41</code>。所以對於結果我們只需考慮、設計執行時間順序。</p><h2 id="多線程同步："><a href="#多線程同步：" class="headerlink" title="多線程同步："></a>多線程同步：</h2><p>如果JS事件共享相同的並列執行資料，問題將會變得微妙得多。考慮這兩個假想代碼段，它們分別描述了執行<code>foo()</code>和<code>bar()</code>中代碼的執行緒將要執行的任務，並考慮如果它們在完全相同的時刻執行會發生什麼：</p><p>執行緒1（<code>X</code>和<code>Y</code>是臨時的記憶體位置）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo():</span><br><span class="line">  a. 將&#96;a&#96;的值讀取到&#96;X&#96;</span><br><span class="line">  b. 將&#96;1&#96;存入&#96;Y&#96;</span><br><span class="line">  c. 把&#96;X&#96;和&#96;Y&#96;相加，將結果存入&#96;X&#96;</span><br><span class="line">  d. 將&#96;X&#96;的值存入&#96;a&#96;</span><br></pre></td></tr></table></figure><p>執行緒2（<code>X</code>和<code>Y</code>是臨時的記憶體位置）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bar():</span><br><span class="line">  a. 將&#96;a&#96;的值讀取到&#96;X&#96;</span><br><span class="line">  b. 將&#96;2&#96;存入&#96;Y&#96;</span><br><span class="line">  c. 把&#96;X&#96;和&#96;Y&#96;相乘，將結果存入&#96;X&#96;</span><br><span class="line">  d. 將&#96;X&#96;的值存入&#96;a&#96;</span><br></pre></td></tr></table></figure><p>由於同步執行，會有以下幾種可能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1a  (將&#96;a&#96;的值讀取到&#96;X&#96;   &#x3D;&#x3D;&gt; &#96;20&#96;)</span><br><span class="line">2a  (將&#96;a&#96;的值讀取到&#96;X&#96;   &#x3D;&#x3D;&gt; &#96;20&#96;)</span><br><span class="line">1b  (將&#96;1&#96;存入&#96;Y&#96;   &#x3D;&#x3D;&gt; &#96;1&#96;)</span><br><span class="line">2b  (將&#96;2&#96;存入&#96;Y&#96;   &#x3D;&#x3D;&gt; &#96;2&#96;)</span><br><span class="line">1c  (把&#96;X&#96;和&#96;Y&#96;相加，將結果存入&#96;X&#96;   &#x3D;&#x3D;&gt; &#96;22&#96;)</span><br><span class="line">1d  (將&#96;X&#96;的值存入&#96;a&#96;   &#x3D;&#x3D;&gt; &#96;22&#96;)</span><br><span class="line">2c  (把&#96;X&#96;和&#96;Y&#96;相乘，將結果存入&#96;X&#96;   &#x3D;&#x3D;&gt; &#96;44&#96;)</span><br><span class="line">2d  (將&#96;X&#96;的值存入&#96;a&#96;   &#x3D;&#x3D;&gt; &#96;44&#96;)</span><br></pre></td></tr></table></figure><p><code>a</code>中的結果將是<code>44</code>。那麼這種順序呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1a  (將&#96;a&#96;的值讀取到&#96;X&#96;   &#x3D;&#x3D;&gt; &#96;20&#96;)</span><br><span class="line">2a  (將&#96;a&#96;的值讀取到&#96;X&#96;   &#x3D;&#x3D;&gt; &#96;20&#96;)</span><br><span class="line">2b  (將&#96;2&#96;存入&#96;Y&#96;   &#x3D;&#x3D;&gt; &#96;2&#96;)</span><br><span class="line">1b  (將&#96;1&#96;存入&#96;Y&#96;   &#x3D;&#x3D;&gt; &#96;1&#96;)</span><br><span class="line">2c  (把&#96;X&#96;和&#96;Y&#96;相乘，將結果存入&#96;X&#96;   &#x3D;&#x3D;&gt; &#96;20&#96;)</span><br><span class="line">1c  (把&#96;X&#96;和&#96;Y&#96;相加，將結果存入&#96;X&#96;   &#x3D;&#x3D;&gt; &#96;21&#96;)</span><br><span class="line">1d  (將&#96;X&#96;的值存入&#96;a&#96;   &#x3D;&#x3D;&gt; &#96;21&#96;)</span><br><span class="line">2d  (將&#96;X&#96;的值存入&#96;a&#96;   &#x3D;&#x3D;&gt; &#96;21&#96;)</span><br></pre></td></tr></table></figure><p><code>a</code>中的結果將是<code>21</code>。</p><hr><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://hackmd.io/_0wj9tH2QX27Iwrc7Zu-GQ" target="_blank" rel="noopener">[筆記] Event loop - HackMD</a><br><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="noopener">YDKJS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;YDKJS-Lesson1-非同步與性能-筆記&quot;&gt;&lt;a href=&quot;#YDKJS-Lesson1-非同步與性能-筆記&quot; class=&quot;headerlink&quot; title=&quot;YDKJS Lesson1 非同步與性能 筆記&quot;&gt;&lt;/a&gt;YDKJS Lesson1 非同步
      
    
    </summary>
    
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="YDKJS" scheme="http://yoursite.com/tags/YDKJS/"/>
    
      <category term="閱讀筆記" scheme="http://yoursite.com/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>【 YDKJS 】Object · Ruru-Front-End-Blog</title><meta name="description" content="【 YDKJS 】Object - [object Object]"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="../../../../favicons.jpg"><link rel="stylesheet" href="../../../../css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/YUN-RU-TSENG/atom.xml" title="Ruru-Front-End-Blog"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="atom.xml" title="Ruru-Front-End-Blog" type="application/atom+xml"></head><body><div class="wrap"><header><a class="logo-link" href="../../../../index.html"><img src="../../../../favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="../../../../index.html" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../https:/github.com/YUN-RU-TSENG" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../https:/mail.google.com/mail/u/0/#inbox?compose=CllgCJTJnslxNqjBDkxGtdSVcGzcSZCczzVSQlprTXfFvBvLQZcwtWnCKxDchvrXJXKtWlzJLtL" target="_blank">FEED</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">【 YDKJS 】Object</h1><div class="post-info">Jul 16, 2020</div><div class="post-content"><h4 id="🎙🎙🎙-nbsp-nbsp-閱讀須知"><a href="#🎙🎙🎙-nbsp-nbsp-閱讀須知" class="headerlink" title="🎙🎙🎙 &nbsp; &nbsp; 閱讀須知"></a>🎙🎙🎙 &nbsp; &nbsp; 閱讀須知</h4><p>本文為筆者閱讀 <strong>You Don’t Know JavaScript</strong> 系列時的學習筆記，有鑒於日益嚴重的健忘問題，也沒有錢可以買銀杏護體，便開始了 <del>大抄</del> 筆記整理的行動 🏃，主要會對書中內容進行心得整理、紀錄一些當下遇到的神秘問題。歡迎一起討論交流，有任何錯誤也請各位大大不吝鞭笞，小菜雞不慎感激 🙇。</p><p><a href="https://www.animatedimages.org/cat-frogs-198.htm" target="_blank" rel="noopener"><img src="https://www.animatedimages.org/data/media/198/animated-frog-image-0204.gif" border="0" alt="animated-frog-image-0204"></a></p><hr><h2 id="物件的生成"><a href="#物件的生成" class="headerlink" title="物件的生成"></a>物件的生成</h2><p>Javascript 物件可以透過兩種方式生成：</p><ol><li>字面值</li><li>建構函式</li></ol><p>以上兩種方法有兩點明顯的差異：執行速度、設定物件屬性的方式。</p><h4 id="差異一：執行速度"><a href="#差異一：執行速度" class="headerlink" title="差異一：執行速度"></a>差異一：執行速度</h4><p>根據 ECMA 5 的描述使用字面值生成物件以及 new Object() 生成物件是相同的</p><blockquote><p>Let array be the result of creating a new object as if by the expression new Array() where Array is the standard built-in constructor with that name.</p></blockquote><p>不過這篇 <a href="https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array" target="_blank" rel="noopener">為什麼 arr = [] 比 arr = new Array 要快？</a> 文章的介紹（範例是 Array），兩者在編譯上的結果會發現，比起 [] 生成物件， new Object 要經過確認 new 並且查找 Array 的過程，以這點來說建構函式花費的時間更多。</p><p>看到編譯結果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]: ARRAY_INIT</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>: NEW, IDENTIFIER</span><br></pre></td></tr></table></figure><p>兩者編譯會如何執行：</p><p><strong>[]</strong>：<code>ARRAY_INIT</code> 初始化陣列<br><strong>new Array</strong>: <code>new</code> 先解析 <code>new</code> 透過 <code>IDENTIFIER</code> 了解要建構物件， 由於遇到了 <code>IDENTIFIER</code> 所以要查詢範圍鍊 …。</p><p>得知 new Array() 顯然要進行更多的步驟，於是會花費更多的時間。</p><p>了解了原因後，我再次按照該提問範例測試了兩者的差異，使用迴圈創造多個物件，分別使用 <code>{}</code> 以及 <code>new Object()</code> 配合 <code>console.timeEnd()</code> 測試，如下方的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"using[]"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"using[]"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"using new"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"using new"</span>);</span><br></pre></td></tr></table></figure><p>結果多次測試下，可以看見字面值方法始終大於 <code>new Object()</code>，在速率上更快：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using []: 524.794ms</span><br><span class="line">using new: 734.315ms</span><br></pre></td></tr></table></figure><p>但是目前若是迴圈生成的物件較少，結果差異並不明顯（迴圈太少，有時 new 會更快），有鑒於這篇文章有些時間，有可能是瀏覽器產生了一些優化，以及關於編譯部分，等待之後再深入研究。</p><blockquote><p>生成 byteCoode 方法： <code>node --print-bytecode xxx.js &gt; result.txt</code> 可以生成 bytecode 到特定 txt 中。等待研究 bytecode 再回來填坑。</p></blockquote><p>等待研究的資料</p><ol><li><a href="https://github.com/aszx87410/blog/issues/54">從 V8 bytecode 看 let 與 var 的效能問題</a></li><li><a href="https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775" target="_blank" rel="noopener">Understanding V8’s Bytecode</a></li></ol><h4 id="差異二：設定物件屬性的方式"><a href="#差異二：設定物件屬性的方式" class="headerlink" title="差異二：設定物件屬性的方式"></a>差異二：設定物件屬性的方式</h4><p>字面值設定屬性可以清晰的建立物件結構，並且一次新增多個屬性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticket = &#123;</span><br><span class="line">  name: <span class="string">"Movie"</span>,</span><br><span class="line">  price: <span class="number">20000</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="danger">這裡的 `price` 後方加上的 `,` 稱為尾隨逗號 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas" target="_blank" rel="noopener">Trailing commas</a>，便於我們添加、刪除和移動屬性。所以要記得添加呦！☘</div><p>但透過建構式，屬性要生成後一個一個添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticket = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次新增一個</span></span><br><span class="line">ticket.name = <span class="string">"Movie"</span>;</span><br><span class="line"><span class="comment">// 一次新增一個</span></span><br><span class="line">ticket.price = <span class="number">20000</span>;</span><br></pre></td></tr></table></figure><p>鑑於方便性，在速率、初始設定多個數值時更為方便等優點，字面值總是為使用上的優先考量。</p><h2 id="物件屬性"><a href="#物件屬性" class="headerlink" title="物件屬性"></a>物件屬性</h2><p>物件是屬性（property）的集合，每個屬性都是一個（key/value）對，可以儲存 8 種數據類型（ 7 種基本型別 ）</p><p>string<br>number<br>boolean<br>null<br>undefined<br>BigInt<br>Symbol<br>object</p><p>其中每個屬性可以為命名數據屬性、命名訪問屬性、內部屬性（三者稍後說明），現在只要先記得這件事即可。</p><p>function 物件不同於其他物件，它具有 [[call]] 屬性，內部屬性通常是為了規範定義、語言實行而存在的。</p><div class="danger">null 是基本型別為 Object 是設計上的失誤，細節可以參考 [“typeof null” 的歷史](https://2ality.com/2013/10/typeof-null.html) 介紹，雖然目前 TC39 積極想處理，但是目前仍為錯誤，我們可以看到 `typeof null = "object"`。</div><h4 id="🎿-神秘的小題目"><a href="#🎿-神秘的小題目" class="headerlink" title="🎿 神秘的小題目"></a>🎿 神秘的小題目</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>(a);</span><br><span class="line"><span class="built_in">console</span>.log(a === b);</span><br></pre></td></tr></table></figure><p>答案是 <code>true</code>，解答：<a href="https://www.zhihu.com/question/285068799/answer/1323222019" target="_blank" rel="noopener">這裏</a></p><h2 id="內置物件"><a href="#內置物件" class="headerlink" title="內置物件"></a>內置物件</h2><p>Javascript 中由 ECMA 所定義，在開始進行時 ECMAScript 程式開始運行時存在，他們為物件的子類別，常見的有（更多可以查見：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">MDN</a>）</p><p>String<br>Number<br>Boolean<br>Object<br>Function<br>Array<br>Date<br>RegExp<br>Error</p><p>上述皆為具有 [[call]] 內部屬性的建構函式，這些函式的 prototype 有許多預設的方法屬性是由規範預先制定，透過建構式生成的物件可以使用這些方法。</p><p>我們可以使用基本型別，使用與之對應名稱的建構式的 prototype 中的方法，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello"</span>;</span><br><span class="line">str.toUpperCase();</span><br></pre></td></tr></table></figure><p>之所以可以這樣處理，是由於 Javascript 的隱式轉型（coercions）以及原型繼承，由規範 ECMA 中我們可以窺見一些緣由：</p><h4 id="12-3-2Property-Accessors"><a href="#12-3-2Property-Accessors" class="headerlink" title="12.3.2Property Accessors"></a>12.3.2Property Accessors</h4><p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-property-accessors-runtime-semantics-evaluation" target="_blank" rel="noopener">12.3.2.1Runtime Semantics: Evaluation</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Let baseReference be the result <span class="keyword">of</span> evaluating MemberExpression.</span><br><span class="line"><span class="number">2.</span> Let baseValue be GetValue(baseReference).</span><br><span class="line"><span class="number">3.</span> ReturnIfAbrupt(baseValue).</span><br><span class="line"><span class="number">4.</span> Let propertyNameReference be the result <span class="keyword">of</span> evaluating Expression.</span><br><span class="line"><span class="number">5.</span> Let propertyNameValue be GetValue(propertyNameReference).</span><br><span class="line"><span class="number">6.</span> ReturnIfAbrupt(propertyNameValue).</span><br><span class="line"><span class="number">7.</span> Let bv be RequireObjectCoercible(baseValue).</span><br><span class="line"><span class="number">8.</span> ReturnIfAbrupt(bv).</span><br><span class="line"><span class="number">9.</span> Let propertyKey be ToPropertyKey(propertyNameValue).</span><br><span class="line"><span class="number">10.</span> ReturnIfAbrupt(propertyKey).</span><br><span class="line"><span class="number">11.</span> If the code matched by the syntactic production that is being evaluated is strict mode code, <span class="keyword">let</span> strict be <span class="literal">true</span>, <span class="keyword">else</span> <span class="keyword">let</span> strict be <span class="literal">false</span>.</span><br><span class="line"><span class="number">12.</span> Return a value <span class="keyword">of</span> type Reference whose base value is bv and whose referenced name is propertyKey, and whose strict reference flag is strict.</span><br></pre></td></tr></table></figure><h4 id="6-2-3-1GetValue-V"><a href="#6-2-3-1GetValue-V" class="headerlink" title="6.2.3.1GetValue (V)"></a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-getvalue" target="_blank" rel="noopener">6.2.3.1GetValue (V)</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. ReturnIfAbrupt(V).</span><br><span class="line">2. If Type(V) is not Reference, return V.</span><br><span class="line">3. Let base be GetBase(V).</span><br><span class="line">4. If IsUnresolvableReference(V), throw a ReferenceError exception.</span><br><span class="line">5. If IsPropertyReference(V), then</span><br><span class="line">  a. If HasPrimitiveBase(V) is true, then</span><br><span class="line">    i. Assert: In this case, base will never be null or undefined.</span><br><span class="line">    ii. Let base be ToObject(base).</span><br><span class="line">  b. Return base.[[Get]](GetReferencedName(V), GetThisValue(V)).</span><br><span class="line">6. Else base must be an Environment Record,</span><br><span class="line">  a. Return base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).</span><br></pre></td></tr></table></figure><p>在使用 <code>getValue()</code> 內部抽象操作時，可見到 <code>Let base be ToObject(base).</code> 在這個步驟時產生了轉型（基本型別為此物件的 <code>[[class]]</code>），透過此臨時物件，配合 <code>[[GET]]</code> 的行為，轉化基本型別為物件，進一步透過該物件，在上頭調用原型上的方法：</p><p>下方描述了 <code>[[Get]]</code> 行為中找尋原型中屬性的行為：</p><h4 id="9-1-8-Get-P-Receiver"><a href="#9-1-8-Get-P-Receiver" class="headerlink" title="9.1.8 [[Get]] (P, Receiver)"></a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver" target="_blank" rel="noopener">9.1.8 <code>[[Get]]</code> (P, Receiver)</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. Assert: IsPropertyKey(P) is true.</span><br><span class="line">2. Let desc be O.[[GetOwnProperty]](P).</span><br><span class="line">3. ReturnIfAbrupt(desc).</span><br><span class="line">4. If desc is undefined, then</span><br><span class="line">  a. Let parent be O.[[GetPrototypeOf]]().</span><br><span class="line">  b. ReturnIfAbrupt(parent).</span><br><span class="line">  c. If parent is null, return undefined.</span><br><span class="line">  d. Return parent.[[Get]](P, Receiver).</span><br><span class="line">5. If IsDataDescriptor(desc) is true, return desc.[[Value]].</span><br><span class="line">6. Otherwise, IsAccessorDescriptor(desc) must be true so, let getter be desc.[[Get]].</span><br><span class="line">7. If getter is undefined, return undefined.</span><br><span class="line">8. Return Call(getter, Receiver).</span><br></pre></td></tr></table></figure><p>可以看見當在內部找不到該屬性時，就會調用 <code>GetPrototypeOf</code> 往原型上查找。就結論上來說，基本型別可以使用相同名稱的建構式 prototype 中的方法，是多虧了轉型以及原型繼承。</p><div class="danger">目前對於調用 a.b 這件行為的理解為 12.3.2.1 行為，並在過程中引用了 reference type 下的 getValue() ，不過查詢了許多資料仍然有點迷惑，所以目前以上的順序仍然是目前的解讀，有可能有誤，這部分等待研究深入。 另外，我們平時使用的物件，都是建構式生成，可以生成沒有原型的嗎？如若可以，定義為何？</div><p>等待研究資料<br><a href="chrome-extension://klbibkeccnjlkjkiokjodocebajanakg/suspended.html#ttl=JavaScript%E5%9F%BA%E5%85%83%E7%9A%84%E7%A7%98%E5%AF%86%E7%94%9F%E6%B4%BB%E2%80%93%20JavaScript%EF%BC%8CJavaScript%E2%80%A6&pos=6017&uri=https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/">The Secret Life of JavaScript Primitives</a></p><hr><p>上述說完了基本型別如何透過轉型、原型來使用內置對象的屬性，下面來介紹如何透過 <code>Object.prototype.toString()</code> 方法查看物件的子類別 <code>[[class]]</code></p><p><code>[[class]]</code> 是規範的內部屬性，表示該物件的子類別，只能夠過 <code>Object.prototype.toString()</code> 查看，並且與 <code>Number.prototype.toString()</code>、<code>Boolean.prototype.toString()</code> 不同，</p><h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a><code>Object.prototype.toString()</code></h4><p>返回 O 的物件類型 type，結果為 <code>[Object type]</code>，其中 type 為規範所定義的 <code>[[class]]</code>，包含：<code>String</code>、<code>Object</code>、<code>Null</code> 等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.toString() <span class="comment">// [object object]</span></span><br></pre></td></tr></table></figure><p>若是要對其他子類型的物件使用，記得使用綁定 <code>this</code> 的方式，因為其他類別內的 <code>toString</code> 跟 <code>Object.prototype.toString()</code> 的作用不相同，若是要得到內部屬性 [[class]]，需使用 <code>Object.prototype.toString()</code>，這也是 ECMA 規範定義的唯一可以取得內部屬性 <code>[[class]]</code> 的方法。</p><blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若是要對 Number 型別使用，記得使用綁定，否則會使用 Number.prototype.toString() 他不會使用 Object.prototype.toString()</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Number</span>()) <span class="comment">// [object Number]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>().toString <span class="comment">// "0"</span></span><br></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h4><p>查看物件原型鏈中是否有某建構式的 <code>prototype</code>，返回 <code>Boolean</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>() <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="🎿-神秘的小題目-1"><a href="#🎿-神秘的小題目-1" class="headerlink" title="🎿 神秘的小題目"></a>🎿 神秘的小題目</h4><p>請問 <code>o3 instanceof C</code> 數值為多少？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defining constructors</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> C()</span><br><span class="line"></span><br><span class="line"><span class="comment">// true, because: Object.getPrototypeOf(o) === C.prototype</span></span><br><span class="line">o <span class="keyword">instanceof</span> C</span><br><span class="line"></span><br><span class="line"><span class="comment">// false, because D.prototype is nowhere in o's prototype chain</span></span><br><span class="line">o <span class="keyword">instanceof</span> D</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Object</span>           <span class="comment">// true, because:</span></span><br><span class="line">C.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">C.prototype = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> C()</span><br><span class="line"></span><br><span class="line">o2 <span class="keyword">instanceof</span> C  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false, because C.prototype is nowhere in</span></span><br><span class="line"><span class="comment">// o's prototype chain anymore</span></span><br><span class="line">o <span class="keyword">instanceof</span> C</span><br><span class="line"></span><br><span class="line">D.prototype = <span class="keyword">new</span> C()  <span class="comment">// add C to [[Prototype]] linkage of D</span></span><br><span class="line"><span class="keyword">let</span> o3 = <span class="keyword">new</span> D()</span><br><span class="line">o3 <span class="keyword">instanceof</span> D        <span class="comment">// true</span></span><br><span class="line">o3 <span class="keyword">instanceof</span> C        <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>答案是： true</p><p>這邊有兩個可以注意的點，一個是 <code>o instanceof C</code> 轉變成 <code>false</code> 的情況，另一個是使用 <code>new c()</code> 作為 D 的 <code>prototype</code>，<code>new D() instanceof C // true</code></p><p>先來說第一點為何會轉變：<br>一開始，<code>o instanceof C</code> 為正確，但是後來 <code>prototype</code> 被重新指向了 <code>{}</code>，此時 <code>o</code> 指向舊的 <code>prototype</code> 但是建構式中的 <code>prototype</code> 已經指向了新的物件，於是 <code>o</code> 的原型鏈中沒有繼承建構式中被重新指向的原型，所以 <code>o instanceof C</code> 轉變成 <code>false</code></p><h4 id="結論：建構式中的-prototype-重新指向新物件，會導致舊有的實例原型鍊中沒有指向此新的物件。"><a href="#結論：建構式中的-prototype-重新指向新物件，會導致舊有的實例原型鍊中沒有指向此新的物件。" class="headerlink" title="結論：建構式中的 prototype 重新指向新物件，會導致舊有的實例原型鍊中沒有指向此新的物件。"></a>結論：建構式中的 prototype 重新指向新物件，會導致舊有的實例原型鍊中沒有指向此新的物件。</h4><p>第二點：<br>設定 <code>D.prototype = new C()</code> 會使得使用 new D() 生成的物件中，原型練會包含 C.prototype，因為 D.prototype 的 new C() 的原型為 C.prototype，於是 <code>o3 instanceof C // true</code></p><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><p>物件可以使用兩中方法取值：</p><ol><li>Obj[expression] 鍵訪問</li><li>Obj.identifier 屬性訪問</li></ol><p>由於鍵訪問內使用的是 expression 所以我們可以在裡面使用計算等方式，動態的組件數值。</p></div></article></div></main><footer><div class="paginator"><a class="next" href="../%E3%80%90Vue-%E5%88%9D%E6%8E%A2%E3%80%91Vue-instance/">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'claymcleod';
var disqus_identifier = 'archives/2020/07/【 Javascript 】Object 中的物件（一）：從常見的 'HI~I'M LUSIR'.toLowerCase() 看隱式轉型/';
var disqus_title = '【 YDKJS 】Object';
var disqus_url = 'https://github.com/YUN-RU-TSENG/archives/2020/07/【 Javascript 】Object 中的物件（一）：從常見的 'HI~I'M LUSIR'.toLowerCase() 看隱式轉型/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script><div class="copyright"><p>© 2020 ruru-tseng, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>.</p><p>Logo made by <a href="https://www.flaticon.com/authors/freepik" target="_blank" rel="noopener">Freepik</a> from <a href="https://flaticon.com" target="_blank" rel="noopener">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>
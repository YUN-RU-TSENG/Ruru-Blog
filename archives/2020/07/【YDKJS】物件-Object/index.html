<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>【 YDKJS 】 Object (筆記版) · Ruru-Front-End-Blog</title><meta name="description" content="【 YDKJS 】 Object (筆記版) - [object Object]"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="../../../../favicons.jpg"><link rel="stylesheet" href="../../../../css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/YUN-RU-TSENG/atom.xml" title="Ruru-Front-End-Blog"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="atom.xml" title="Ruru-Front-End-Blog" type="application/atom+xml"></head><body><div class="wrap"><header><a class="logo-link" href="../../../../index.html"><img src="../../../../favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="../../../../index.html" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../https:/github.com/YUN-RU-TSENG" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../https:/mail.google.com/mail/u/0/#inbox?compose=CllgCJTJnslxNqjBDkxGtdSVcGzcSZCczzVSQlprTXfFvBvLQZcwtWnCKxDchvrXJXKtWlzJLtL" target="_blank">FEED</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">【 YDKJS 】 Object (筆記版)</h1><div class="post-info">Jul 16, 2020</div><div class="post-content"><h4 id="🎙🎙🎙-nbsp-nbsp-閱讀須知"><a href="#🎙🎙🎙-nbsp-nbsp-閱讀須知" class="headerlink" title="🎙🎙🎙 &nbsp; &nbsp; 閱讀須知"></a>🎙🎙🎙 &nbsp; &nbsp; 閱讀須知</h4><p>本文為筆者閱讀 <strong>You Don’t Know JavaScript</strong> 系列時的心得，有鑒於日益嚴重的健忘問題，也沒有錢可以買銀杏護體，便開始了 <del>大抄</del> 筆記整理的行動 🏃，主要會對書中內容進行心得整理、紀錄一些當下遇到的神秘問題。歡迎一起討論交流，有任何錯誤也請各位大大不吝鞭笞，小菜雞不慎感激 🙇。</p><p><a href="https://www.animatedimages.org/cat-frogs-198.htm" target="_blank" rel="noopener"><img src="https://www.animatedimages.org/data/media/198/animated-frog-image-0204.gif" border="0" alt="animated-frog-image-0204"></a></p><hr><h1 id="🔖-nbsp-Object，你好"><a href="#🔖-nbsp-Object，你好" class="headerlink" title="🔖&nbsp; Object，你好"></a>🔖&nbsp; <code>Object</code>，你好</h1><p>Javascript 中，<code>Object</code>依照來源可以區分為：</p><img src="./screenshot 2020-07-16 20.58.24.jpg"><ol><li>宿主物件：由宿主環境提供的<code>Object</code> <em>object supplied by the host environment to complete the execution environment of ECMAScript</em></li><li>原生物件：由 ECMAScript 實現提供，不包含宿主環境定義的<code>Object</code>。 <em>object in an ECMAScript implementation whose semantics are fully defined by this specification rather than by the host environment</em></li></ol><ul><li>包含內置物件：Date、String …</li></ul><h2 id="宿主物件"><a href="#宿主物件" class="headerlink" title="宿主物件"></a>宿主物件</h2><p>剛剛有說到 <strong>宿主物件</strong> 是由 <strong>宿主環境</strong> 提供的物件，那麼什麼是 <strong>宿主環境</strong> 呢？</p><p>我們現在所撰寫的 JavaScript ，需要透過宿主環境（瀏覽器、Node）執行，以瀏覽器來說：比如我們常用的 Chrome、Safari 等，都是可以使 JavaScript 運行的環境，這便被稱為 <strong>宿主環境</strong>，一個運作 Javascript 腳本的環境，而宿主環境如今也不僅僅只有瀏覽器，Node 也可以作為宿主環境，大大提升了 Javascript 可被應用的場合。</p><h4 id="宿主環境中的-Object："><a href="#宿主環境中的-Object：" class="headerlink" title="宿主環境中的 Object："></a>宿主環境中的 <code>Object</code>：</h4><p>規範中 <a href="http://ecma-international.org/ecma-262/5.1/#sec-4.1" target="_blank" rel="noopener">4.1</a> 有如此提到：</p><blockquote><p>A web browser provides an ECMAScript host environment for client-side computation including, for instance, objects that represent windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, and input/output. Further, the host environment provides a means to attach scripting code to events such as change of focus, page and image loading, unloading, error and abort, selection, form submission, and mouse actions. Scripting code appears within the HTML and the displayed page is a combination of user interface elements and fixed and computed text and images. The scripting code is reactive to user interaction and there is no need for a main program.</p></blockquote><p>上面的意思提到了瀏覽器環境提供的宿主物件，可以理解為，宿主環境通常會藉由提供特別的 <code>Object</code> 使 JavaScript 可以藉由操作這些 <code>Object</code> 得以使用宿主環境所提供的功能。</p><p>以瀏覽器來說：</p><p>諸如我們常用的 <code>document</code>、<code>window</code>、<code>cookie</code> 等瀏覽器中提供中的這些 <code>Object</code> 便是我們常會用到的宿主物件，使得 JavaScript 可以藉由操作這些宿主物件處理瀏覽器所提供的功能，諸如點擊按鈕後更換主題色、暫存網頁資料。</p><p>JavaScript 在瀏覽器中可以使用瀏覽器所提供的 Web api，來進行常用的 DOM、Cookie 等操作，與 Event 連用，便可以與用戶交互，舉例來說以下為常見的瀏覽器 <strong>宿主物件</strong>：</p><ul><li>☝&nbsp; document 可以藉由它所提供的諸多屬性，操作有關 Dom 的相關功能。</li><li>☝&nbsp; console 你知道的。</li><li>☝&nbsp; localStorage 可以用來操作瀏覽器的本地存取功能，常見如 sessionStorage、localStorage。</li></ul><img src="./screenshot 2020-07-16 17.11.07.jpg"><p>可以想像 Javascript 在瀏覽器中運行，便可以使用該宿主環境所提供的 <code>Object</code>。<br><br></p><img src="./screenshot 2020-07-16 18.14.09.jpg"> 若是在其他宿主環境，便會有不同的宿主物件可以使用。<hr><h2 id="原生物件："><a href="#原生物件：" class="headerlink" title="原生物件："></a>原生物件：</h2><p>說回 YDKJS 的內容，原生物件便是由 ECMAScript 所定義的物件，平時我們使用 <code>{}</code> 字面值、<code>new Object()</code> 等方式創建的物件便是原生物件的一種，而內置物件也屬於原生物件，如 Date、String 等屬於此範疇。</p><h4 id="建立物件的方法一共有兩種："><a href="#建立物件的方法一共有兩種：" class="headerlink" title="建立物件的方法一共有兩種："></a>建立物件的方法一共有兩種：</h4><img src="./screenshot 2020-07-16 23.42.11.jpg"><ol><li><code>{}</code> 字面值</li><li>new Object()</li></ol><p>字面值建立物件更為直觀，可以清晰地看見物件結構：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">"Henry"</span>,</span><br><span class="line">  sex: <span class="string">"man"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建構式建立物件則有一項明顯的缺點，便是得要 <span style="color:#fc766a;font-weight:700">一個一個新增數值</span>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 新增 name</span></span><br><span class="line">a.name = <span class="string">"Henry"</span>;</span><br><span class="line"><span class="comment">// 新增 man</span></span><br><span class="line">a.sex = <span class="string">"man"</span>;</span><br></pre></td></tr></table></figure><h4 id="那麼，new-Object-以及-都可以生成物件，到底該使用哪個呢？"><a href="#那麼，new-Object-以及-都可以生成物件，到底該使用哪個呢？" class="headerlink" title="那麼，new Object 以及 {} 都可以生成物件，到底該使用哪個呢？"></a>那麼，new Object 以及 {} 都可以生成物件，到底該使用哪個呢？</h4><p>答案當然是 <code>{}</code> ，因為 <code>{}</code> 更為直觀。除此之外，根據這一篇 stackoverflow 所提到的問題:</p><p><a href="https://stackoverflow.com/questions/4597926/what-is-the-difference-between-new-object-and-object-literal-notation" target="_blank" rel="noopener">What is the difference between <code>new Object()</code> and object literal notation?</a></p><p>其實可以發現近兩者在執行速率上有些許的差異：</p><p>使用 <code>console.time</code> 來比較 <code>{}</code> 以及 <code>new Object</code> 生成物件，以下為比較生成 <code>100000000</code> 個 <code>{}</code> 以及 <code>10000000</code> 個 <code>new Object()</code> 的差異：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"using&#123;&#125;"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"using&#123;&#125;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"using new"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"using new"</span>);</span><br></pre></td></tr></table></figure><p>以下為執行結果：</p><ol><li>{} 需要 1095 毫秒</li><li>new Object 需要 1205 毫秒</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Testing Object:</span><br><span class="line">using&#123;&#125;: 1095.606201171875ms</span><br><span class="line">using new: 1205.525146484375ms</span><br></pre></td></tr></table></figure><p>根據 <a href="https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array" target="_blank" rel="noopener">Why is arr = [] faster than arr = new Array?</a> 的解釋，可以看到有人從 token 編譯方向去比較兩者的差異，使用 <code>{}</code> 可以減少需要花費額外的 CPU 來確定 new Object 的操作，不過針對這段，由於對於編譯代碼的不熟悉，於是暫時筆記下來，之後再回顧檢討。</p><blockquote><p>結論： <code>{}</code> 可以更直觀、更快捷的生成新的物件</p></blockquote><p><strong>💊 &nbsp; 等待筆記、閱讀的相關資源</strong><br><a href="https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array" target="_blank" rel="noopener">Why is arr = [] faster than arr = new Array?</a></p><hr><h4 id="補充編譯-bytecode-比較差異的方法："><a href="#補充編譯-bytecode-比較差異的方法：" class="headerlink" title="補充編譯 bytecode 比較差異的方法："></a>補充編譯 bytecode 比較差異的方法：</h4><p>建立 <code>{}.js</code> 以及 <code>constructor.js</code> 兩者分別裝載了以下內容：</p><h4 id="包含"><a href="#包含" class="headerlink" title="{} 包含"></a>{} 包含</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="建構式-包含"><a href="#建構式-包含" class="headerlink" title="建構式 包含"></a>建構式 包含</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>使用 <strong>node</strong> <code>node --print-bytecode 要編譯的檔案.js &gt; 要輸出的 bytecode 結果.txt</code> 查看兩者的編譯結果，結果上兩者並非完全相同，使用 diff 比較兩者是有差異的。不過這一部份目前不確定的很多，首先 bytecode 我不太會看，所以先當成一個疑惑，留著以後深入筆記。</p><p><strong>💊 &nbsp; 等待筆記、閱讀的相關資源</strong><br><a href="https://github.com/aszx87410/blog/issues/54">從 V8 bytecode 看 let 與 var 的效能問題<br>#54</a></p><hr><h2 id="內置物件："><a href="#內置物件：" class="headerlink" title="內置物件："></a>內置物件：</h2><p>剛介紹完了原生物件，Javascript 原生物件中還包含了內置物件，在 Javascript 開始執行後，便會存在於環境中可供使用，其中下列常見的基本類別有各自對應的內置物件名稱：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><p>以上的內置物件皆為函式，可以透過建構函式方式呼叫，由於 JS 原型繼承的設計，每個構造器函式的 prototype 將被生成的物件隱式的引用，這部分之後會詳細說明，不過可以先看下段 ECMA 中的介紹：</p><blockquote><p>Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s “prototype” property. Furthermore, a prototype may have a non-null implicit reference to its prototype, and so on; this is called the prototype chain. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on</p></blockquote><h4 id="Javascript-中的建構子："><a href="#Javascript-中的建構子：" class="headerlink" title="Javascript 中的建構子："></a>Javascript 中的建構子：</h4><p>簡單來說，Javascript 沒有 class 的設計，由於當初只是一個簡單設計的腳本語言，所以設計者設計了建構子（擁有 prototype 的函式，透過 new 表達式生成對象）讓生成的物件得以隱性的引用連結建構式的 prototype，便可以達成屬性共享、原型繼承的功能。</p><img src="./screenshot 2020-07-17 11.28.44.jpg"><p>以上圖來說，建構子生成 A1、A2、A3 三個物件，每個物件都有各自的屬性：</p><p>黃線代表原型繼承，建構子本身的 <code>p1</code>、<code>p2</code> 對於 <code>prototype</code> 以及 <code>A1</code>、<code>A2</code>、<code>A3</code> 是不可見的，然後位於 <code>prototype</code> 中的屬性（只要 <code>A1</code>、<code>A2</code>、<code>A3</code> 不含有該屬性名，不然就會以 <code>A1</code>、<code>A2</code>、<code>A3</code> 本身的該屬性名優先）可以被 <code>A1</code>、<code>A2</code>、<code>A3</code> 共享。</p><p><strong>注意，建構子和 <code>prototype</code> 是沒有隱性繼承的關係的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建構子</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="function"><span class="keyword">function</span>(<span class="params">a1, a2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a1 = a1;</span><br><span class="line">    <span class="keyword">this</span>.a2 = a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建構子的 prototype</span></span><br><span class="line">p.prototype = &#123;</span><br><span class="line">    method1: <span class="string">'...'</span>,</span><br><span class="line">    method2: <span class="string">'...'</span>,</span><br><span class="line">    method3: <span class="string">'...'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 new p 建構的物件</span></span><br><span class="line"><span class="keyword">var</span> A1 = <span class="keyword">new</span> p(<span class="number">12</span>, <span class="number">22</span>)</span><br><span class="line"><span class="keyword">var</span> A2 = <span class="keyword">new</span> p(<span class="number">3</span>, <span class="number">33</span>)</span><br><span class="line"><span class="keyword">var</span> A3 = <span class="keyword">new</span> p(<span class="number">5</span>, <span class="number">67</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這些物件繼承了 p.prototype，指向 prototype 位址</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(A1) === p.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(A2) === p.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(A3) === p.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">A1.method1 <span class="comment">// '...'</span></span><br><span class="line">p.method1 <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>可以實際執行一次程式碼。記得 <code>p</code> 建構子不會繼承自己的 <code>prototype</code> 屬性，所以 <code>p.method1</code> 並沒有值。</p><h2 id="回到內置物件"><a href="#回到內置物件" class="headerlink" title="回到內置物件"></a>回到內置物件</h2><p>看過上述建構子介紹後，相信大家可以猜想到透過建構子的特性，Javascript 的內置建構子也有它所定義的 <code>prototype</code>，並且乘載著好用的屬性，例如 String 建構子的 prototype ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">anchor: ƒ anchor()</span><br><span class="line">big: ƒ big()</span><br><span class="line">blink: ƒ blink()</span><br><span class="line">bold: ƒ bold()</span><br><span class="line">charAt: ƒ charAt()</span><br><span class="line">charCodeAt: ƒ charCodeAt()</span><br><span class="line">codePointAt: ƒ codePointAt()</span><br><span class="line">concat: ƒ concat()</span><br><span class="line"><span class="keyword">constructor</span>: ƒ String()</span><br><span class="line">endsWith: ƒ endsWith()</span><br><span class="line">fixed: ƒ fixed()</span><br><span class="line">fontcolor: ƒ fontcolor()</span><br><span class="line">fontsize: ƒ fontsize()</span><br><span class="line">includes: ƒ includes()</span><br><span class="line">indexOf: ƒ indexOf()</span><br><span class="line">italics: ƒ italics()</span><br><span class="line">lastIndexOf: ƒ lastIndexOf()</span><br><span class="line">length: 0</span><br><span class="line">link: ƒ link()</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>包含如上許多可用的功能，可以查詢 charcode、可以更換特定文字，只要透過 <code>new String()</code> 生成的物件，都可以因為原型繼承，可以直接使用這些方法。但是，平時我們時常使用的 <code>&#39;Alice&#39;</code> 等字串也可以使用 <code>&#39;Alice&#39;.chartat()</code> 等方法，相信你一定不陌生，這是由於 javascript coercion（轉型），在使用以下方法時會使用內部方法 toObject(V) 將字串 <code>&#39;Alice&#39;</code> 轉型成為 <code>String 物件</code>，有人稱這過程為 <code>boxing</code> 或是此時物件為 <code>wrapper object</code> 但是規範中沒有出現相關關鍵詞，其為一個討論此概念的說法。</p><p>下面來看看轉型時我們自規範可以窺見什麼</p><h4 id="6-2-3-1"><a href="#6-2-3-1" class="headerlink" title="6.2.3.1"></a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-getvalue" target="_blank" rel="noopener">6.2.3.1</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. ReturnIfAbrupt(V).</span><br><span class="line">2. If Type(V) is not Reference, return V.</span><br><span class="line">3. Let base be GetBase(V).</span><br><span class="line">4. If IsUnresolvableReference(V), throw a ReferenceError exception.</span><br><span class="line">5. If IsPropertyReference(V), then.</span><br><span class="line">    a.If HasPrimitiveBase(V) is true, then.</span><br><span class="line">        i. Assert: In this case, base will never be null or undefined.</span><br><span class="line">        ii. Let base be ToObject(base).</span><br><span class="line">    b.Return base.[[Get]](GetReferencedName(V), GetThisValue(V)).</span><br><span class="line">6. Else base must be an Environment Record,</span><br><span class="line">    a.Return base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).</span><br></pre></td></tr></table></figure><p>由此方法我們可以看見，當出現 <code>&#39;Alice&#39;</code>.charat() 時，Alice 的 reference type（此為 javascript 內部屬性，為一個抽象 instance，當 identify 解析、屬性訪問過程中會創建，base 為引用基值、name 為引用名稱、strict 表示是否為嚴格模式：</p><h4 id="reference-示意"><a href="#reference-示意" class="headerlink" title="reference 示意"></a>reference 示意</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base: &#96;&#39;Alice&#39;&#96;</span><br><span class="line">name: charat</span><br><span class="line">strice: false</span><br></pre></td></tr></table></figure><p>套用到上述 a ii. 可以看見當 base 數值為非物件的基本型別，此時會將 base 值透過 toObject(base) 轉型，並且返回轉型後查找到的屬性，故在此便可以使用基本型別來使用內部屬性。</p><h4 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h4><p><a href="http://perfectionkills.com/know-thy-reference/" target="_blank" rel="noopener">reference</a><br><a href="https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/" target="_blank" rel="noopener">The Secret Life of JavaScript Primitives</a></p></div></article></div></main><footer><div class="paginator"><a class="next" href="../%E3%80%90Vue-%E5%88%9D%E6%8E%A2%E3%80%91Vue-instance/">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname="claymcleod",disqus_identifier="archives/2020/07/【YDKJS】物件-Object/",disqus_title="【 YDKJS 】 Object (筆記版)",disqus_url="https://github.com/YUN-RU-TSENG/archives/2020/07/【YDKJS】物件-Object/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script><div class="copyright"><p>© 2020 ruru-tseng, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>.</p><p>Logo made by <a href="https://www.flaticon.com/authors/freepik" target="_blank" rel="noopener">Freepik</a> from <a href="https://flaticon.com" target="_blank" rel="noopener">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>